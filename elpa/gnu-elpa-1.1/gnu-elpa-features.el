;;; gnu-elpa-features.el --- Auto-generated autoloads  -*- lexical-binding:t -*-

;; ¡¡ This file is auto-generated by `gnu-elpa--make-features', DO NOT EDIT !!

;; Copyright (C) 2020-2020  Free Software Foundation, Inc.

;; Author: gnu-elpa-maint.el

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Code:

;; Don't edit this file, it's auto-generated by `gnu-elpa--make-features'!

(dolist (x '((ace-window-display-mode "Minor mode for showing the ace window key in the mode line.

(fn &optional ARG)" t nil)
             (ace-window "Select a window.
Perform an action based on ARG described below.

By default, behaves like extended `other-window'.

Prefixed with one \\[universal-argument], does a swap between the
selected window and the current window, so that the selected
buffer moves to current window (and current buffer moves to
selected window).

Prefixed with two \\[universal-argument]'s, deletes the selected
window.

(fn ARG)" t nil)
             (ace-maximize-window "Ace maximize window.

(fn)" t nil)
             (ace-swap-window "Ace swap window.

(fn)" t nil)
             (ace-delete-window "Ace delete window.

(fn)" t nil)
             (ace-select-window "Ace select window.

(fn)" t nil)
             (pcomplete/ag "Completion for the `ag' command.

(fn)" nil nil)
             (pcomplete/ack "Completion for the `ack' command.
Start an argument with `-' to complete short options and `--' for
long options.

(fn)" nil nil)
             (ack "Run ack using COMMAND-ARGS and collect output in a buffer.
When called interactively, the value of DIRECTORY is provided by
`ack-default-directory-function'.

The following keys are available while reading from the
minibuffer:

\\{ack-minibuffer-local-map}

(fn COMMAND-ARGS &optional DIRECTORY)" t nil)
             (adaptive-wrap-prefix-mode "Wrap the buffer text with adaptive filling.

If called interactively, enable Adaptive-Wrap-Prefix mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (adjust-parens-mode "Indent and dedent Lisp code, automatically adjust close parens.

If called interactively, enable Adjust-Parens mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (advice-patch "Replace OLDCODE with NEWCODE in the definition of NAME.
OLDCODE is an S-expression to replace in the source code.
It can also be a vector of S-expressions, so that you can specify the various original source codes found in various Emacs versions.

(fn NAME NEWCODE OLDCODE)" nil nil)
             (global-aggressive-indent-mode "Toggle Aggressive-Indent mode in all buffers.
With prefix ARG, enable Global Aggressive-Indent mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Aggressive-Indent mode is enabled in all buffers where
`aggressive-indent-mode' would do it.
See `aggressive-indent-mode' for more information on Aggressive-Indent mode.

(fn &optional ARG)" t nil)
             (aggressive-indent-mode "Toggle Aggressive-Indent mode on or off.
With a prefix argument ARG, enable Aggressive-Indent mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{aggressive-indent-mode-map}

(fn &optional ARG)" t nil)
             (aggressive-indent-indent-region-and-on "Indent region between L and R, and then some.
Call `indent-region' between L and R, and then keep indenting
until nothing more happens.

(fn L R)" t nil)
             (aggressive-indent-indent-defun "Indent current defun.
Throw an error if parentheses are unbalanced.
If L and R are provided, use them for finding the start and end of defun.

(fn &optional L R)" t nil)
             (all "Show all lines in the current buffer containing a match for REGEXP.

If a match spreads across multiple lines, all those lines are shown.

Each line is displayed with NLINES lines before and after, or -NLINES
before if NLINES is negative.
NLINES defaults to `list-matching-lines-default-context-lines'.
Interactively it is the prefix arg.

The lines are shown in a buffer named `*All*'.
Any changes made in that buffer will be propagated to this buffer.

(fn REGEXP &optional NLINES)" t nil)
             (ampc "Ampc is an asynchronous client for the MPD media player.
This function is the main entry point for ampc.

HOST and PORT specify the MPD instance to connect to.  The values
default to the ones specified in `ampc-default-server'.

(fn &optional HOST PORT SUSPEND)" t nil)
             (ampc-on-p "Return non-nil if ampc is connected to the daemon." t nil)
             (ampc-suspended-p "Return non-nil if ampc is suspended." t nil)
             (ampc-tag-files "Start the tagging subsystem.
FILES should be a list of absolute file names, the files to tag.

(fn FILES)" nil nil)
             (ampc-tagger-dired "Start the tagging subsystem on dired's marked files.
With optional prefix argument ARG, use the next ARG files.

(fn &optional ARG)" t nil)
             (ampc-tagger-dired-mode "Minor mode that adds a audio file meta data tagging key binding to dired.

If called interactively, enable Ampc-Tagger-Dired mode if ARG is
positive, and disable it if ARG is zero or negative.  If called from
Lisp, also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (arbitools-mode "Major mode for Chess Tournament Management.

(fn)" t nil)
             (aa2u-mark-rectangle-as-text "Like ‘aa2u-mark-as-text’ on the region-rectangle.
When called from a program the rectangle's corners
are START (top left) and END (bottom right).

(fn START END &optional UNMARK)" t nil)
             (aa2u-mark-as-text "Set property ‘aa2u-text’ of the text from START to END.
This prevents ‘aa2u’ from misinterpreting \"|\", \"-\" and \"+\"
in that region as lines and intersections to be replaced.
Prefix arg means to remove property ‘aa2u-text’, instead.

(fn START END &optional UNMARK)" t nil)
             (aa2u-rectangle "Like ‘aa2u’ on the region-rectangle.
When called from a program the rectangle's corners
are START (top left) and END (bottom right).

(fn START END)" t nil)
             (aa2u "Convert simple ASCII art line drawings to Unicode.
Specifically, perform the following replacements:

  - (hyphen)          BOX DRAWINGS LIGHT HORIZONTAL
  | (vertical bar)    BOX DRAWINGS LIGHT VERTICAL
  + (plus)            (one of)
                      BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
                      BOX DRAWINGS LIGHT DOWN AND RIGHT
                      BOX DRAWINGS LIGHT DOWN AND LEFT
                      BOX DRAWINGS LIGHT UP AND RIGHT
                      BOX DRAWINGS LIGHT UP AND LEFT
                      BOX DRAWINGS LIGHT VERTICAL AND RIGHT
                      BOX DRAWINGS LIGHT VERTICAL AND LEFT
                      BOX DRAWINGS LIGHT UP AND HORIZONTAL
                      BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
                      BOX DRAWINGS LIGHT UP
                      BOX DRAWINGS LIGHT DOWN
                      BOX DRAWINGS LIGHT LEFT
                      BOX DRAWINGS LIGHT RIGHT
                      QUESTION MARK

More precisely, hyphen and vertical bar are substituted unconditionally,
first, and plus is substituted with a character depending on its north,
south, east and west neighbors.

NB: Actually, ‘aa2u’ can also use \"HEAVY\" instead of \"LIGHT\",
depending on the value of variable ‘aa2u-uniform-weight’.

This command operates on either the active region,
or the accessible portion otherwise.

(fn BEG END &optional INTERACTIVE)" t nil)
             (dired-async-do-rename "Run ‘dired-do-rename’ asynchronously.

(fn &optional ARG)" t nil)
             (dired-async-do-hardlink "Run ‘dired-do-hardlink’ asynchronously.

(fn &optional ARG)" t nil)
             (dired-async-do-symlink "Run ‘dired-do-symlink’ asynchronously.

(fn &optional ARG)" t nil)
             (dired-async-do-copy "Run ‘dired-do-copy’ asynchronously.

(fn &optional ARG)" t nil)
             (dired-async-mode "Do dired actions asynchronously.

If called interactively, enable Dired-Async mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (async-byte-compile-file "Byte compile Lisp code FILE asynchronously.

Same as `byte-compile-file' but asynchronous.

(fn FILE)" t nil)
             (async-bytecomp-package-mode "Byte compile asynchronously packages installed with package.el.
Async compilation of packages can be controlled by
`async-bytecomp-allowed-packages'.

If called interactively, enable Async-Bytecomp-Package mode if
ARG is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (async-byte-recompile-directory "Compile all *.el files in DIRECTORY asynchronously.
All *.elc files are systematically deleted before proceeding.

(fn DIRECTORY &optional QUIET)" nil nil)
             (async-start "Execute START-FUNC (often a lambda) in a subordinate Emacs process.
When done, the return value is passed to FINISH-FUNC.  Example:

    (async-start
       ;; What to do in the child process
       (lambda ()
         (message \"This is a test\")
         (sleep-for 3)
         222)

       ;; What to do when it finishes
       (lambda (result)
         (message \"Async process done, result should be 222: %s\"
                  result)))

If FINISH-FUNC is nil or missing, a future is returned that can
be inspected using `async-get', blocking until the value is
ready.  Example:

    (let ((proc (async-start
                   ;; What to do in the child process
                   (lambda ()
                     (message \"This is a test\")
                     (sleep-for 3)
                     222))))

        (message \"I'm going to do some work here\") ;; ....

        (message \"Waiting on async process, result should be 222: %s\"
                 (async-get proc)))

If you don't want to use a callback, and you don't care about any
return value from the child process, pass the `ignore' symbol as
the second argument (if you don't, and never call `async-get', it
will leave *emacs* process buffers hanging around):

    (async-start
     (lambda ()
       (delete-file \"a remote file on a slow link\" nil))
     \\='ignore)

Note: Even when FINISH-FUNC is present, a future is still
returned except that it yields no value (since the value is
passed to FINISH-FUNC).  Call `async-get' on such a future always
returns nil.  It can still be useful, however, as an argument to
`async-ready' or `async-wait'.

(fn START-FUNC &optional FINISH-FUNC)" nil nil)
             (async-start-process "Start the executable PROGRAM asynchronously.  See `async-start'.
PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the
process object when done.  If FINISH-FUNC is nil, the future
object will return the process object when the program is
finished.  Set DEFAULT-DIRECTORY to change PROGRAM's current
working directory.

(fn NAME PROGRAM FINISH-FUNC &rest PROGRAM-ARGS)" nil nil)
             (aumix "Run the aumix program in a buffer.
An *aumix* buffer is created if it doesn't already exist.
See `aumix-mode' for details of operating the mode.

(fn)" t nil)
             (aumix-mode "Major mode for running the aumix program.
Key bindings are per the aumix program.  Press `k' for a summary,
or see KEYS in \"man aumix\".  `\\[aumix-mode-quit]' quits and kills the buffer.

The various terminal setups of `term-mode' are unchanged.  Note
in Emacs 24 the ANSI colours use `font-lock-mode' so be sure
that's turned on (which it is by default).  In Emacs 21 the
opposite was true; if you turn on font lock then you lose the
colours.

In XEmacs 21.4, term.el doesn't seem to work very well with
ncurses programs.  A message \"Error opening terminal: eterm\" is
from aumix (the ncurses library) complaining the terminfo is not
found.  Adding TERMINFO=/usr/share/xemacs21/xemacs-packages/etc/
or wherever the /e/eterm file lives might help.  If something
doesn't work then C-c C-x C-k will kill the buffer.

`clone-buffer' doesn't work on an aumix-mode buffer, as of Emacs
24.3.  Two or more aumix programs can run simultaneously (their
displays update with the underlying mixer settings), so perhaps
`clone-buffer' could be made to work.  A `rename-buffer' and
second `M-x aumix' works.  But normally only a single aumix-mode
buffer is desired.

----
The aumix home page is
  URL `http://jpj.net/~trevor/aumix.html'
The aumix-mode.el home page is
  URL `http://user42.tuxfamily.org/aumix-mode/index.html'

----
\\{aumix-mode-map}

(fn)" nil nil)
             (auto-correct-scan "Scan the buffer or region for misspelled words.

When a misspelled word is found, offer to correct the misspelled
word and auto-correct the typo in the future.

When `auto-correct-mode' is enabled, use the `ispell' command
instead.

(fn)" t nil)
             (auto-correct-scan-region "Scan the region between START and END for misspelled words.

Interactively, START and END are the current region.

When a misspelled word is found, offer to correct the misspelled
word and auto-correct the typo in the future.

When `auto-correct-mode' is enabled, use the `ispell' command
instead.

(fn START END)" t nil)
             (auto-correct-scan-buffer "Scan current buffer for misspelled words.

When a misspelled word is found, offer to correct the misspelled
word and auto-correct the typo in the future.

When `auto-correct-mode' is enabled, use the `ispell' command
instead.

(fn)" t nil)
             (auto-correct-fix-and-add "Use `ispell-word' to fix a misspelled word at point.

Once the misspelled word is fixed, auto-correct will remember the
fix and auto-correct it from then on, so long as
`auto-correct-mode' is enabled.

With a non-nil argument LOCAL (interactively, the prefix argument),
create a fix for the typo that will be auto-corrected for buffers
using the current local mode.

This is pointless to use when `auto-correct-mode' is enabled;
instead, use `ispell-word' and `auto-correct-toggle-ispell-local'
to use the local abbrev table.

(fn LOCAL)" t nil)
             (auto-correct-mode "Activate automatic corrections.

Auto correct expansions will only work when this mode is enabled,
but auto-correct can be trained with `auto-correct-fix-and-add'
even if this mode is disabled.

When this mode is enabled, corrections made with flyspell and
Ispell will be made automatically after fixing them once.

In order to add corrections to the auto-correct abbrev table in
flyspell (and thus have them corrected later), set
`flyspell-use-global-abbrev-table-p' to non-nil.

In order to set corrections as local using Ispell, use
the command `auto-correct-toggle-ispell-local'.

\\{auto-correct-mode-map}

(fn &optional ARG)" t nil)
             (auto-overlay-load-overlays "Load overlays for BUFFER from FILE.
Returns t if successful, nil otherwise.
Defaults to the current buffer.

If FILE is null, or is a string that only specifies a directory,
the filename is constructed from the buffer's file name and
SET-ID. If the buffer is not associated with a file and FILE
doesn't specify a full filename, an error occurs.

The FILE should be generated by `auto-overlay-save-overlays'. By
default, the buffer contents and regexp definitions for SET-ID
will be checked to make sure neither have changed since the
overlays were saved. If they don't match, the saved overlay data
will not be loaded, and the function will return nil.

If NO-REGEXP-CHECK is non-nil, the check for matching regexp
definitions will be skipped; the saved overlays will be loaded
even if different regexp definitions were active when the
overlays were saved.

(fn SET-ID &optional BUFFER FILE NO-REGEXP-CHECK)" nil nil)
             (auto-overlay-share-regexp-set "Make TO-BUFFER share the regexp set identified by SET-ID with FROM-BUFFER.
Any changes to that regexp set in either buffer will be reflected in the
other. TO-BUFFER defaults to the current buffer.

(fn SET-ID FROM-BUFFER &optional TO-BUFFER)" nil nil)
             (auto-overlay-load-regexp "Load REGEXP into the auto-overlay definition identified by
DEFINITION-ID in the regexp list named SET-ID in the current
buffer.

If POS is nil, REGEXP is added at the end of the definition. If
it is t, it is added at the beginning. If it is an integer, it is
added at that position.


REGEXP should be a list of the form:

  (RGXP &optional :edge EDGE :id REGEXP-ID
        &rest PROPERTY1 PROPERTY2 ... )

RGXP is either a single regular expression (a string), or a cons
cell of the form (RGXP . GROUP) where RGXP is a regular
expression and GROUP is an integer specifying which group in the
regular expression forms the delimiter for the auto-overlay. The
rest of the PROPERTY entries should be cons cells of the
form (NAME . VALUE) where NAME is an overlay property name (a
symbol) and VALUE is its value.

The properties :edge and :id are optional. The :edge property
EDGE should be one of the symbols `start' or `end'. If it is not
specified, :edge is assumed to be `start'. The :id property is a
symbol that can be used to uniquely identify REGEXP (see
`auto-overlay-unload-regexp').

(fn SET-ID DEFINITION-ID REGEXP &optional POS)" nil nil)
             (auto-overlay-load-definition "Load DEFINITION into the set of auto-overlay definitions SET-ID
in the current buffer. If SET-ID does not exist, it is created.

If POS is nil, DEFINITION is added at the end of the list of
auto-overlay definitions. If it is t, it is added at the
beginning. If it is an integer, it is added at that position in
the list. The position in the list makes no difference to the
behaviour of the auto-overlays. But it can make a difference to
the speed and efficiency. In general, higher-priority and
exclusive DEFINITIONS should appear earlier in the list.

If DEFINITION-ID is supplied, it should be a symbol that can be
used to uniquely identify DEFINITION (see
`auto-overlay-unload-definition').


DEFINITION should be a list of the form:

  (CLASS @optional :id DEFINITION-ID @rest REGEXP1 REGEXP2 ... )

CLASS is a symbol specifying the auto-overlay class. The standard
classes are `word', `line', `self', `flat' and `nested'. The :id
property is optional. It should be a symbol that can be used to
uniquely identify DEFINITION (see
`auto-overlay-unload-definition').

The REGEXP's should be lists of the form:

  (RGXP &optional :edge EDGE :id REGEXP-ID
        &rest PROPERTY1 PROPERTY2 ... )

RGXP is either a single regular expression (a string), or a cons
cell of the form (RGXP . GROUP) where RGXP is a regular
expression and GROUP is an integer specifying which group in the
regular expression forms the delimiter for the auto-overlay. The
rest of the PROPERTY entries should be cons cells of the
form (NAME . VALUE) where NAME is an overlay property name (a
symbol) and VALUE is its value.

The properties :edge and :id are optional. The :edge property
EDGE should be one of the symbols `start' or `end'. If it is not
specified, :edge is assumed to be `start'. The :id property is a
symbol that can be used to uniquely identify REGEXP (see
`auto-overlay-unload-regexp').

(fn SET-ID DEFINITION &optional POS)" nil nil)
             (auto-overlay-local-binding "Return \"overlay local \" binding of SYMBOL at POINT,
or the current local binding if there is no overlay binding. If
there is no overlay binding and SYMBOL is not bound, return
nil. POINT defaults to the point.

If ONLY-OVERLAY is non-nil, only overlay bindings are
returned. If none exists at POINT, nil is returned

An \"overlay local\" binding is created by giving an overlay a
non-nil value for a property named SYMBOL. If more than one
overlay at POINT has a non-nil SYMBOL property, the value from
the highest priority overlay is returned.

See `auto-overlay-highest-priority-at-point' for a definition of
\"highest priority\".

(fn SYMBOL &optional POINT ONLY-OVERLAY)" nil nil)
             (auto-overlay-highest-priority-at-point "Return highest priority overlay at POINT (defaults to the point).

If two overlays have the same priority, the innermost one takes
precedence (i.e. the one that begins later, or if they begin at
the same point the one that ends earlier).

See `auto-overlays-at' for ane explanation of the PROPTEST argument.

(fn &optional POINT PROPTEST)" nil nil)
             (auto-overlays-in "Return auto overlays overlapping region between START and END.

If PROP-TEST is supplied, it should be a list which specifies a
property test with one of the following forms (or a list of such
lists if more than one property test is required):

  (FUNCTION PROPERTY)

  (FUNCTION PROPERTY VALUE)

  (FUNCTION (PROPERTY1 PROPERTY2 ...) (VALUE1 VALUE2 ...))

where PROPERTY indicates an overlay property name (a symbol), and
VALUE indicates an arbitrary value or lisp expression.

For each overlay between START and END, first the values
corresponding to the property names are retrieved from the
overlay, then FUNCTION is called with the properties values
followed by the other values as its arguments. The test is
satisfied if the result is non-nil, otherwise it fails. Tests are
evaluated in order, but only up to the first failure. Only
overlays that satisfy all property tests are returned.

If WITHIN is non-nil, only overlays entirely within START and END
are returned. If INACTIVE is non-nil, both active and inactive
overlays are returned (usually inactive ones are ignored).

Note that this function returns any overlay. If you want to
restrict it to auto overlays, include (identity auto-overlay) in
PROP-TEST.

(fn START END &optional PROP-TEST WITHIN INACTIVE)" nil nil)
             (auto-overlays-at-point "Return overlays overlapping POINT
(or the point, if POINT is null). If PROP-TEST is supplied, it
should be a list which specifies a property test with one of the
following forms (or a list of such lists if more than one
property test is required):

  (FUNCTION PROPERTY)

  (FUNCTION PROPERTY VALUE)

  (FUNCTION (PROPERTY1 PROPERTY2 ...) (VALUE1 VALUE2 ...))

where PROPERTY indicates an overlay property name (a symbol), and
VALUE indicates an arbitrary value or lisp expression.

For each overlay overlapping POINT, first the values
corresponding to the property names are retrieved from the
overlay, then FUNCTION is called with the properties values
followed by the other values as its arguments. The test is
satisfied if the result is non-nil, otherwise it fails. Tests are
evaluated in order, but only up to the first failure. Only
overlays that satisfy all property tests are returned.

If INACTIVE is non-nil, both active and inactive overlays are
returned (usually inactive ones are ignored).

Note that this function returns any overlay. If you want to
restrict it to auto overlays, include (identity auto-overlay) in
PROP-TEST.

(fn &optional POINT PROP-TEST INACTIVE)" nil nil)
             (beacon-mode "Toggle Beacon mode on or off.
With a prefix argument ARG, enable Beacon mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{beacon-mode-map}

(fn &optional ARG)" t nil)
             (beacon-blink "Blink the beacon at the position of the cursor.
Unlike `beacon-blink-automated', the beacon will blink
unconditionally (even if `beacon-mode' is disabled), and this can
be invoked as a user command or called from lisp code.

(fn)" t nil)
             (bluetooth-list-devices "Display a list of Bluetooth devices.
This function starts Bluetooth mode which offers an interface
offering device management functions, e.g. pairing, connecting,
scanning the bus, displaying device info etc." t nil)
             (bnf-mode "A major mode for editing BNF grammars.

\\{bnf-mode-map}
The variable `bnf-mode-algol-comments-style' can be changed to control
comments style used in grammars.

Turning on BNF mode calls the value of `prog-mode-hook' and then of
`bnf-mode-hook', if they are non-nil.

(fn)" t nil)
             (brief-easy-start "Emulate Brief by changing less favored Emacs settings for programmers.
Before enabling brief mode this sets the following:
 1) No line wrapping by setting `truncate-lines' 't.
 2) No jumppy scrolling in both vertical and horizontal directions.
 3) Smaller borders.
This function is used by the quick launcher 'b' script." t nil)
             (brief-mode "Enable/Disable/Toggle Brief emulation mode.
With a prefix argument ARG, enable Brief mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.  If called interactively without ARG,
toggle brief-mode.

(fn &optional ARG)" t nil)
             (buffer-expose-project-no-stars "Expose buffers of `projectile-project-buffers' omitting *special* ones.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-project-stars "Expose *special* buffers of `projectile-project-buffers'.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-project "Expose buffers of `projectile-project-buffers'.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-dired-buffers "Expose dired buffers of `buffer-list'.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-no-stars "Expose buffers of `buffer-list' omitting *special* ones.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to
`buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-stars "Expose *special* buffers of `buffer-list'.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-major-mode "Expose buffers with major mode MODE.

MAX is the maximum number of windows to show per page, which
defaults to `buffer-expose-max-num-windows'.

(fn MAX MODE)" t nil)
             (buffer-expose-current-mode "Expose buffers with mode of current major mode.

MAX is the maximum number of windows to show per page, which
defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose "Expose buffers of `buffer-list'.

If MAX is given it determines the maximum number of windows to
show per page, which defaults to `buffer-expose-max-num-windows'.

(fn &optional MAX)" t nil)
             (buffer-expose-mode "Expose buffers.

If called interactively, enable Buffer-Expose mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Instantiate bindings of `buffer-expose-mode-map'.

(fn &optional ARG)" t nil)
             (bug-hunter-init-file "Test ASSERTION throughout `user-init-file'.
All sexps inside `user-init-file' are read and passed to
`bug-hunter-hunt' as a list.  See `bug-hunter-hunt' for how to use
ASSERTION.

(fn &optional ASSERTION)" t nil)
             (bug-hunter-file "Bisect FILE while testing ASSERTION.
All sexps in FILE are read and passed to `bug-hunter-hunt' as a
list.  See `bug-hunter-hunt' for how to use ASSERTION.

(fn FILE &optional ASSERTION)" t nil)
             (caps-lock-mode "Make self-inserting keys invert the capitalization.

(fn &optional ARG)" t nil)
             (global-captain-mode "Toggle Captain mode in all buffers.
With prefix ARG, enable Global Captain mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Captain mode is enabled in all buffers where
`captain-mode' would do it.
See `captain-mode' for more information on Captain mode.

(fn &optional ARG)" t nil)
             (captain-mode "Call the captain to automatically capitalize the start of every sentence.

The captain will also automatically capitalize words you've told
him you want capitalized with `captain-capitalize-word'.

\\{captain-mode-map}

(fn &optional ARG)" t nil)
             (chess-tutorial "A simple chess training display." t nil)
             (chess-fischer-random-position "Generate a Fischer Random style position." nil nil)
             (chess-puzzle "Pick a random puzzle from FILE, and solve it against the default engine.
The spacebar in the display buffer is bound to `chess-puzzle-next',
making it easy to go on to the next puzzle once you've solved one.

(fn FILE &optional INDEX)" t nil)
             (chess-pgn-mode "A mode for editing chess PGN files.

(fn)" t nil)
             (chess-pgn-read "Read and display a PGN game after point.

(fn &optional FILE)" t nil)
             (chess-link "Play out a game between two engines, and watch the progress.
If you want to run an engine as a bot, make the transport the first
engine, and the computer the second engine.

(fn FIRST-ENGINE-TYPE SECOND-ENGINE-TYPE)" t nil)
             (chess-ics "Connect to an Internet Chess Server.

(fn SERVER PORT &optional HANDLE PASSWORD-OR-FILENAME HELPER &rest HELPER-ARGS)" t nil)
             (chess-create-display "Create a display, letting the user's customization decide the style.
If MODULES-TOO is non-nil, also create and associate the modules
listed in `chess-default-modules'.

(fn PERSPECTIVE &optional MODULES-TOO)" nil nil)
             (chess "Start a game of chess, playing against ENGINE (a module name).
With prefix argument, prompt for the engine to play against.
Otherwise use `chess-default-engine' to determine the engine.

(fn &optional ENGINE DISABLE-POPUP ENGINE-RESPONSE-HANDLER &rest ENGINE-CTOR-ARGS)" t nil)
             (clipboard-collector-create "Create clipboard collector command named NAME.

Calling the command will start a timer which checks the clipboard
for changes. If the content of a clipboard change match a rule of
RULES with format of `clipboard-collector--rules', it is
collected according to the rule.

The command will enable `clipboard-collector-mode' which will
bind `clipboard-collector-finish' to finish collecting items
using FINISHF which defaults to
`clipboard-collector-finish-default'.

(fn NAME RULES &optional FINISHF)" nil t)
             (clipboard-collector-mode "Start collecting clipboard items.

If called interactively, enable Clipboard-Collector mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Rules used are defined in `clipboard-collector--rules'. Because
this mode is only for temporary use and you want its bindings to
have precedence over all other ones when activated,
`clipboard-collector-mode-map' is made transient while this mode
is active.

(fn &optional ARG)" t nil)
             (cobol-mode "COBOL mode is a major mode for handling COBOL files.

(fn)" t nil)
             (coffee-mode "Major mode for editing CoffeeScript.

(fn)" t nil)
             (global-compact-docstrings-mode "Toggle Compact-Docstrings mode in all buffers.
With prefix ARG, enable Global Compact-Docstrings mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Compact-Docstrings mode is enabled in all buffers where
`compact-docstrings--mode-on' would do it.
See `compact-docstrings-mode' for more information on Compact-Docstrings mode.

(fn &optional ARG)" t nil)
             (compact-docstrings-mode "Shrink empty lines in docstrings and doc comments.

(fn &optional ARG)" t nil)
             (company-ebdb "`company-mode' completion backend for EBDB.

(fn COMMAND &optional ARG &rest IGNORE)" t nil)
             (company-math-symbols-unicode "Company backend for insertion of Unicode mathematical symbols.
COMMAND and ARG is as required by company backends.
See the unicode-math page [1] for a list of fonts that have a
good support for mathematical symbols. Unicode provides only a
limited range of sub(super)scripts; see the wikipedia page [2]
for details.

 [1] http://ftp.snt.utwente.nl/pub/software/tex/help/Catalogue/entries/unicode-math.html
 [2] https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts

(fn COMMAND &optional ARG &rest IGNORED)" t nil)
             (company-math-symbols-latex "Company backend for LaTeX mathematical symbols.
COMMAND and ARG is as required by company backends.

(fn COMMAND &optional ARG &rest IGNORED)" t nil)
             (company-latex-commands "Company backend for latex commands.
COMMAND and ARG is as required by company backends.

(fn COMMAND &optional ARG &rest IGNORED)" t nil)
             (company-statistics-mode "Statistical sorting for company-mode.  Ranks completion candidates by
the frequency with which they have been chosen in recent (as given by
`company-statistics-size') history.

Turning this mode on and off preserves the statistics.  They are also
preserved automatically between Emacs sessions in the default
configuration.  You can customize this behavior with
`company-statistics-auto-save', `company-statistics-auto-restore' and
`company-statistics-file'.

(fn &optional ARG)" t nil)
             (context-coloring-js2-colorize "Color the buffer using the `js2-mode'.

(fn)" nil nil)
             (context-coloring-eval-expression-predicate "Non-nil if the minibuffer is for `eval-expression'.

(fn)" nil nil)
             (context-coloring-eval-expression-colorize "Color the `eval-expression' minibuffer prompt as elisp.

(fn)" t nil)
             (context-coloring-elisp-colorize "Color the current Emacs Lisp buffer.

(fn)" t nil)
             (context-coloring-mode "Toggle contextual code coloring.
With a prefix argument ARG, enable Context Coloring mode if ARG
is positive, and disable it otherwise.  If called from Lisp,
enable the mode if ARG is omitted or nil.

Context Coloring mode is a buffer-local minor mode.  When
enabled, code is colored by scope.  Scopes are colored
hierarchically.  Variables referenced from nested scopes retain
the color of their defining scopes.  Certain syntax, like
comments and strings, is still colored with `font-lock'.

The entire buffer is colored initially.  Changes to the buffer
trigger recoloring.

Define your own colors by customizing faces like
`context-coloring-level-N-face', where N is a number starting
from 0.  If no face is found on a custom theme nor the `user'
theme, the defaults are used.

New language / major mode support can be added with
`context-coloring-define-dispatch', which see.

Feature inspired by Douglas Crockford.

(fn &optional ARG)" t nil)
             (crisp-mode "Toggle CRiSP/Brief emulation (CRiSP mode).
With a prefix argument ARG, enable CRiSP mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

(fn &optional ARG)" t nil)
             (tsv-mode "Major mode for editing files of tab-separated value type.

(fn)" t nil)
             (csv-mode "Major mode for editing files of comma-separated value type.

CSV mode is derived from `text-mode', and runs `text-mode-hook' before
running `csv-mode-hook'.  It turns `auto-fill-mode' off by default.
CSV mode can be customized by user options in the CSV customization
group.  The separators are specified by the value of `csv-separators'.

CSV mode commands ignore blank lines and comment lines beginning with
the value of `csv-comment-start', which delimit \"paragraphs\".
\"Sexp\" is re-interpreted to mean \"field\", so that `forward-sexp'
(\\[forward-sexp]), `kill-sexp' (\\[kill-sexp]), etc. all apply to fields.
Standard comment commands apply, such as `comment-dwim' (\\[comment-dwim]).

If `font-lock-mode' is enabled then separators, quoted values and
comment lines are highlighted using respectively `csv-separator-face',
`font-lock-string-face' and `font-lock-comment-face'.

The user interface (UI) for CSV mode commands is similar to that of
the standard commands `sort-fields' and `sort-numeric-fields', except
that if there is no prefix argument then the UI prompts for the field
index or indices.  In `transient-mark-mode' only: if the region is not
set then the UI attempts to set it to include all consecutive CSV
records around point, and prompts for confirmation; if there is no
prefix argument then the UI prompts for it, offering as a default the
index of the field containing point if the region was not set
explicitly.  The region set automatically is delimited by blank lines
and comment lines, and the number of header lines at the beginning of
the region given by the value of `csv-header-lines' are skipped.

Sort order is controlled by `csv-descending'.

CSV mode provides the following specific keyboard key bindings:

\\{csv-mode-map}

(fn)" t nil)
             (cycle-quotes "Cycle between string quote styles.

(fn)" t nil)
             (darkroom-tentative-mode "Enters `darkroom-mode' when all other windows are deleted.

If called interactively, enable DarkRoom-Tentative mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (darkroom-mode "Remove visual distractions and focus on writing. When this
mode is active, everything but the buffer's text is elided from
view. The buffer margins are set so that text is centered on
screen. Text size is increased (display engine allowing) by
`darkroom-text-scale-increase'.

If called interactively, enable Darkroom mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (dbus-codegen-make-proxy "Create a new D-Bus proxy based on the introspection data.

If the data type of the D-Bus proxy is not yet defined, this will
define it with `dbus-codegen-define-proxy', under a type name NAME.

BUS is either a Lisp symbol, `:system' or `:session', or a string
denoting the bus address.

SERVICE is the D-Bus service name to be used.  PATH is the D-Bus
object path SERVICE is registered at.  INTERFACE is an interface
offered by SERVICE.

INTERFACE is an interface which is represented by this proxy.

ARGS are keyword-value pair.  Currently only one keyword is
supported:

:redefine FLAG -- if FLAG is non-nil, redefine the data type and
associated functions.

Other keywords are same as `dbus-codegen-define-proxy'.

(fn NAME BUS SERVICE PATH INTERFACE &rest ARGS)" nil nil)
             (dbus-codegen-define-proxy "Define a new D-Bus proxy NAME.
This defines a new struct type for the proxy and convenient
functions for D-Bus method calls and signal registration.

XML is either a string which defines the interface of the D-Bus
proxy, or a Lisp form which returns a string.  The format of the
string must comply with the standard D-Bus introspection data
format as described in:
`http://dbus.freedesktop.org/doc/dbus-specification.html#introspection-format'.

INTERFACE is a name of interface which is represented by this
proxy.

ARGS are keyword-value pair.  Currently only one keyword is
supported:

:transform-name FUNCTION -- FUNCTION is a function which converts
D-Bus method/signal/property names, into another representation.
By default `dbus-codegen-transform-name' is used.

(fn NAME XML INTERFACE &rest ARGS)" nil t)
             (delight "Modify the lighter value displayed in the mode line for the given mode SPEC
if and when the mode is loaded.

SPEC can be either a mode symbol, or a list containing multiple elements of
the form (MODE VALUE FILE). In the latter case the two optional arguments are
omitted, as they are instead specified for each element of the list.

For minor modes, VALUE is the replacement lighter value (or nil to disable)
to set in the `minor-mode-alist' variable. For major modes VALUE is the
replacement buffer-local `mode-name' value to use when a buffer changes to
that mode.

In both cases VALUE is commonly a string, but may in fact contain any valid
mode-line construct. For details see the `mode-line-format' variable, and
Info node `(elisp) Mode Line Format'.

The FILE argument is passed through to `eval-after-load'. If FILE is nil then
the mode symbol is passed as the required feature. If FILE is t then it is
assumed that the mode is already loaded. (Note that you can also use 'emacs
for this purpose). These FILE options are relevant to minor modes only.

For major modes you should specify the keyword :major as the value of FILE,
to prevent the mode being treated as a minor mode.

(fn SPEC &optional VALUE FILE)" nil nil)
             (read-dict "Read the name of a dictionary with completion, and return it.

Prompt with PROMPT. By default, return DEFAULT. If DICTLIST is
supplied, only complete on dictionaries in that list.

If ALLOW-UNLOADED is non-nil, also complete on the names of
unloaded dictionaries (actually, on any Elisp file in the current
`load-path' restricted to subdirectories of your home directory
whose file name starts with \"dict-\"). If an unloaded dictionary
is read, the name of the Elisp file will be returned, without
extension, suitable for passing to `load-library'.

(fn PROMPT &optional DEFAULT DICTLIST ALLOW-UNLOADED ALLOW-UNMATCHED)" nil nil)
             (dictree-load "Load a dictionary object from file FILE.
Returns the dictionary if successful, nil otherwise.

Interactively, FILE is read from the mini-buffer.

(fn FILE)" t nil)
             (dictree-p "Return t if OBJ is a dictionary tree, nil otherwise.

(fn OBJ)" nil nil)
             (make-dictree-meta-dict "Create a meta-dictionary based on the list of dictionaries
in DICTIONARY-LIST.

COMBINE-FUNCTION is used to combine data from different
dictionaries. It is passed two pieces of data, each an
association of the same key, but in different dictionaries. It
should return a combined datum.

The other arguments are as for `dictree-create'. Note that
caching is only possible if NAME is supplied, otherwise the
CACHE-THRESHOLD argument is ignored and caching is disabled.

(fn DICTIONARY-LIST &optional NAME FILENAME AUTOSAVE UNLISTED COMBINE-FUNCTION CACHE-POLICY CACHE-THRESHOLD CACHE-UPDATE-POLICY)" nil nil)
             (make-dictree-custom "Create an empty dictionary and return it.

The NAME through PLIST-LOADFUN arguments are as for
`dictree-create' (which see).

The remaining arguments control the type of trie to use as the
underlying data structure. See `trie-create' for details.

(fn &optional NAME FILENAME AUTOSAVE UNLISTED &key COMPARISON-FUNCTION INSERT-FUNCTION RANK-FUNCTION CACHE-POLICY CACHE-THRESHOLD CACHE-UPDATE-POLICY KEY-SAVEFUN KEY-LOADFUN DATA-SAVEFUN DATA-LOADFUN PLIST-SAVEFUN PLIST-LOADFUN CREATEFUN INSERTFUN DELETEFUN LOOKUPFUN MAPFUN EMPTYFUN STACK-CREATEFUN STACK-POPFUN STACK-EMPTYFUN TRANSFORM-FOR-PRINT TRANSFORM-FROM-READ)" nil nil)
             (make-dictree "Create an empty dictionary and return it.

If NAME is supplied, the dictionary is stored in the variable
NAME. Defaults to FILENAME stripped of directory and
extension. (Regardless of the value of NAME, the dictionary will
be stored in the default variable name when it is reloaded from
file.)

FILENAME supplies a directory and file name to use when saving
the dictionary. If the AUTOSAVE flag is non-nil, then the
dictionary will automatically be saved to this file when it is
unloaded or when exiting Emacs.

If UNLISTED is non-nil, the dictionary will not be added to the
list of loaded dictionaries. Note that this disables autosaving.

COMPARE-FUNCTION sets the function used to compare elements of
the keys. It should take two arguments, A and B, both of the type
contained by the sequences used as keys (e.g. if the keys will
be strings, the function will be passed two characters). It
should return t if the first is \"less than\" the
second. Defaults to `<'.

INSERT-FUNCTION sets the function used to insert data into the
dictionary. It should take two arguments: the new data, and the
data already in the dictionary, and should return the data to
insert. Defaults to replacing any existing data with the new
data.

RANK-FUNCTION sets the function used to rank the results of
`dictree-complete'. It should take two arguments, each a cons
whose car is a dictree key (a sequence) and whose cdr is the data
associated with that key. It should return non-nil if the first
argument is \"better\" than the second, nil otherwise. It
defaults to \"lexicographic\" comparison of the keys, ignoring
the data (which is not very useful, since an unranked
`dictree-complete' query already does this much more
efficiently).

CACHE-POLICY should be a symbol (`time', `length',
`time-and-length' or `time-or-length'), which determines which
query operations are cached. The `time' setting caches queries
that take longer (in seconds) than the CACHE-THRESHOLD value.

The `length' setting caches query operations based on the length
of the string involved the query. For this setting, CACHE-POLICY
should be a plist with properties :long and :short. Lookups,
fuzzy matches, and regexp queries that do not end in \".*\" will
be cached if the string is longer than the :long value (since
long strings are likely to be the slower ones in these
cases). Completions, fuzzy completions, and regexp queries that
end in \".*\" will be cached if the string or regexp is shorter
than the :short value (since short strings are likely to be the
slower ones for those cases).

The `time-and-length' setting only caches results if both
conditions are satisfied simultaneously, whereas the
`time-or-length' setting caches results if either condition is
satisfied. For these settings, CACHE-THRESHOLD must be a plist
with properties :time, :long and :short, specifying the
corresponding cache thresholds.

CACHE-THRESHOLD defaults to nil. The values nil and t are
special. If CACHE-THRESHOLD is set to nil, no caching is done. If
it is t, everything is cached for that type of query (similar
behaviour can be obtained by setting the a `time' CACHE-THRESHOLD
of 0, but it is better to use t).

CACHE-UPDATE-POLICY should be a symbol (`synchronize' or
`delete'), which determines how the caches are updated when data
is inserted or deleted. The former updates tainted cache entries,
which makes queries faster but insertion and deletion slower,
whereas the latter deletes any tainted cache entries, which makes
queries slower but insertion and deletion faster.

KEY-SAVEFUN, DATA-SAVEFUN and PLIST-SAVEFUN are functions used to
convert keys, data and property lists into lisp objects that have
a valid read syntax, for writing to file. DATA-SAVEFUN and
PLIST-SAVEFUN are used when saving the dictionary (see
`dictree-save' and `dictree-write'), and all three functions are
used when dumping the contents of the dictionary (see
`dictree-dump-to-buffer' and `dictree-dump-to-file').
KEY-SAVEFUN, DATA-SAVEFUN and PLIST-SAVEFUN should each accept
one argument: a key, data or property list from DICT,
respectively. They should return a lisp object which has a valid
read syntax. When defining these functions, be careful not to
accidentally modify the lisp object in the dictionary; usually,
you will need to make a copy before converting it.

KEY-LOADFUN, DATA-LOADFUN and PLIST-LOADFUN are used to convert
keys, data and property lists back again when loading a
dictionary (only DATA-LOADFUN and PLIST-LOADFUN, see
`dictree-save' and `dictree-write') or populating it from a
file (all three, see `dictree-populate-from-file'). They should
accept one argument: a lisp object of the type produced by the
corresponding SAVEFUN, and return a lisp object to use in the
loaded dictionary.

TRIE-TYPE sets the type of trie to use as the underlying data
structure. See `trie-create' for details.

(fn &optional NAME FILENAME AUTOSAVE UNLISTED COMPARISON-FUNCTION INSERT-FUNCTION RANK-FUNCTION CACHE-POLICY CACHE-THRESHOLD CACHE-UPDATE-POLICY KEY-SAVEFUN KEY-LOADFUN DATA-SAVEFUN DATA-LOADFUN PLIST-SAVEFUN PLIST-LOADFUN TRIE-TYPE)" nil nil)
             (diff-hl-margin-mode "Toggle displaying `diff-hl-mode' highlights on the margin.

If called interactively, enable Diff-Hl-Margin mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (diff-hl-flydiff-mode "Perform highlighting on-the-fly.
This is a global minor mode.  It alters how `diff-hl-mode' works.

If called interactively, enable Diff-Hl-Flydiff mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (diff-hl-dired-mode-unless-remote "

(fn)" nil nil)
             (diff-hl-dired-mode "Toggle VC diff highlighting on the side of a Dired window.

If called interactively, enable Diff-Hl-Dired mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (global-diff-hl-amend-mode "Toggle Diff-Hl-Amend mode in all buffers.
With prefix ARG, enable Global Diff-Hl-Amend mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Diff-Hl-Amend mode is enabled in all buffers where
`turn-on-diff-hl-amend-mode' would do it.
See `diff-hl-amend-mode' for more information on Diff-Hl-Amend mode.

(fn &optional ARG)" t nil)
             (diff-hl-amend-mode "Show changes against the second-last revision in `diff-hl-mode'.
Most useful with backends that support rewriting local commits,
and most importantly, \"amending\" the most recent one.
Currently only supports Git, Mercurial and Bazaar.

(fn &optional ARG)" t nil)
             (global-diff-hl-mode "Toggle Diff-Hl mode in all buffers.
With prefix ARG, enable Global Diff-Hl mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Diff-Hl mode is enabled in all buffers where
`turn-on-diff-hl-mode' would do it.
See `diff-hl-mode' for more information on Diff-Hl mode.

(fn &optional ARG)" t nil)
             (turn-on-diff-hl-mode "Turn on `diff-hl-mode' or `diff-hl-dir-mode' in a buffer if appropriate." nil nil)
             (diff-hl-mode "Toggle VC diff highlighting.

If called interactively, enable Diff-Hl mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (diffview-message "Show `message-mode' buffer in a side-by-side view.

This is useful for reading patches from mailing lists.

(fn)" t nil)
             (diffview-region "Show current diff region in a side-by-side view.

(fn)" t nil)
             (diffview-current "Show current diff buffer in a side-by-side view.

(fn)" t nil)
             (dired-du-insert-marked-dirs "Insert all marked subdirectories." t nil)
             (dired-du-count-sizes "Count sizes of files marked with MARK.
If MARK evaluates nil, then use `dired-marker-char'.

Optional arg ALL-MARKS, if non-nil, then accept all mark characters.

Optional arg INCLUDE-DIRS, if non-nil, include the recursive size of the
marked directories.
If called interactively with a prefix, then prompt for previous
args.  Otherwise, all optional arguments but INCLUDE-DIRS are nil, and
INCLUDE-DIRS is set to variable `dired-du-mode'.

Directories '.' '..' are not special: if they are marked, then return
their recursive size.

(fn MARK &optional ALL-MARKS INCLUDE-DIRS)" t nil)
             (dired-du-mode "Toggle dired-du mode.
Interactively with no argument, this command toggles the mode.
A positive prefix argument enables the mode, any other prefix
argument disables it.  From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

If called interactively, enable Dired-Du mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

Show the recursive size of directories in Dired buffers.
Once this mode is enabled, every new Dired buffer displays
recursive dir sizes.
The directory size is obtained with `dired-du-used-space-program'.

Note that obtaining the recursive size of all the directories
in a Dired buffer might be slow; thus, it may significantly delay
the time to display a new Dired buffer.

Instead of enabling `dired-du-mode' by default in all Dired buffers
you might prefer to use this mode as a convenient interface to
the `du' program: just enable it in the current Dired buffer,
and disable it once you have finished checking the used space.

(fn &optional ARG)" t nil)
             (dired-git-info-auto-enable "Enable `dired-git-info-mode' if current dired buffer is in a git repo.

Add this function to `dired-after-readin-hook' to enable the mode
automatically inside git repos." nil nil)
             (dired-git-info-mode "Toggle git message info in current dired buffer.

If called interactively, enable Dired-Git-Info mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (disk-usage-by-types-here "Run `disk-usage-by-types' in current directory." t nil)
             (disk-usage-by-types "

(fn &optional DIRECTORY)" t nil)
             (disk-usage-here "Run `disk-usage' in current directory." t nil)
             (disk-usage "Display listing of files in DIRECTORY with their size.
If DIRECTORY is nil, use current directory.

(fn &optional DIRECTORY)" t nil)
             (log-session-mode "Minor mode to log a session (keystrokes, timestamps etc).

(fn &optional ARG)" t nil)
             (dismal-mode "A major mode for editing SpreadSheets.
A command menu is available by typing C-c C-m (C-m is also RET).
\\[dis-copy-to-dismal] will paste text from another buffer into dismal.
The left mouse button is bound to `dis-mouse-highlight-cell-or-range'
and right mouse button is bound to `dis-mouse-highlight-row'.

 Special commands:
\\{dismal-map}

 Special commands:
\\{dismal-minibuffer-map}
" t nil)
             (djvu-bookmark-handler "Handler to jump to a particular bookmark location in a djvu document.
BMK is a bookmark record, not a bookmark name (i.e., not a string).
Changes current buffer and point and returns nil, or signals a `file-error'.

(fn BMK)" nil nil)
             (djvu-inspect-file "Inspect Djvu FILE on PAGE.
Call djvused with the same sequence of arguments that is used
by `djvu-init-page'.  Display the output in `djvu-script-buffer'.
This may come handy if `djvu-find-file' chokes on a Djvu file.

(fn FILE &optional PAGE)" t nil)
             (djvu-find-file "Read and edit Djvu FILE on PAGE.  Return Read buffer.
If VIEW is non-nil start external viewer.
If NOSELECT is non-nil visit FILE, but do not make it current.
If NOCONFIRM is non-nil don't ask for confirmation when reverting buffer
from file.

(fn FILE &optional PAGE VIEW NOSELECT NOCONFIRM)" t nil)
             (djvu-dummy-mode "Djvu dummy mode for `auto-mode-alist'." nil nil)
             (docbook-find-file "Visit FILENAME as a DocBook document.

(fn FILENAME)" t nil)
             (dts-mode "Major mode for editing Device Tree source files.

(fn)" t nil)
             (easy-mark "Similar to `easy-kill' (which see) but for marking.

(fn &optional N)" t nil)
             (easy-kill "Kill thing at point in the order of region, url, email and line.
Temporally activate additional key bindings as follows:

  letters => select or expand selection according to `easy-kill-alist';
  1..9    => expand selection by that number;
  0       => shrink to the initial selection;
  +,=/-   => expand or shrink selection;
  @       => append selection to previous kill;
  ?       => help;
  C-w     => kill selection;
  C-SPC   => turn selection into an active region;
  C-g     => abort;
  others  => save selection and exit.

(fn &optional N)" t nil)
             (ediprolog-localize "After `ediprolog-localize', any Prolog process started from
this buffer becomes buffer-local.

(fn)" t nil)
             (ediprolog-consult "Buffer is loaded into a Prolog process. If NEW-PROCESS is
non-nil, start a new process. Otherwise use the existing process,
if any. In case of errors, point is moved to the position of the
first error, and the mark is left at the previous position.

In transient mark mode, if the region is active, the function
operates on the region.

(fn &optional NEW-PROCESS)" t nil)
             (ediprolog-remove-interactions "Remove all lines starting with `ediprolog-prefix' from buffer.

In transient mark mode, if the region is active, the function
operates on the region.

(fn)" t nil)
             (ediprolog-interact "Send QUERY to Prolog process and interact as on a terminal.

You can use \\[keyboard-quit] to unblock Emacs in the case of
longer-running queries. When the query completes and the toplevel
asks for input, use \\[ediprolog-toplevel] to resume interaction
with the Prolog process.

(fn QUERY)" nil nil)
             (ediprolog-dwim "Load current buffer into Prolog or post query (Do What I Mean).
If invoked on a line starting with `:-' or `?-', possibly
preceded by `%' and whitespace, call `ediprolog-interact' with
the query as argument. Otherwise, call `ediprolog-consult'.

With prefix argument 0, kill the Prolog process. With prefix 1,
equivalent to `ediprolog-consult'. With prefix 2, equivalent to
`ediprolog-consult' with a new Prolog process. With prefix 7,
equivalent to `ediprolog-toplevel'. With just C-u, first call
`ediprolog-consult' and then, if point is on a query, call
`ediprolog-interact' with it as argument. Analogously, C-u C-u
for `ediprolog-consult' with a new process. With other prefix
arguments, equivalent to `ediprolog-remove-interactions'.

(fn &optional ARG)" t nil)
             (eev-beginner "Load all basic modules of eev, turn eev-mode on, and open a tutorial." t nil)
             (eglot-ensure "Start Eglot session for current buffer if there isn't one." nil nil)
             (eglot "Manage a project with a Language Server Protocol (LSP) server.

The LSP server of CLASS started (or contacted) via CONTACT.  If
this operation is successful, current *and future* file buffers
of MANAGED-MAJOR-MODE inside PROJECT automatically become
\"managed\" by the LSP server, meaning information about their
contents is exchanged periodically to provide enhanced
code-analysis via `xref-find-definitions', `flymake-mode',
`eldoc-mode', `completion-at-point', among others.

Interactively, the command attempts to guess MANAGED-MAJOR-MODE
from current buffer, CLASS and CONTACT from
`eglot-server-programs' and PROJECT from `project-current'.  If
it can't guess, the user is prompted.  With a single
\\[universal-argument] prefix arg, it always prompt for COMMAND.
With two \\[universal-argument] prefix args, also prompts for
MANAGED-MAJOR-MODE.

PROJECT is a project instance as returned by `project-current'.

CLASS is a subclass of symbol `eglot-lsp-server'.

CONTACT specifies how to contact the server.  It is a
keyword-value plist used to initialize CLASS or a plain list as
described in `eglot-server-programs', which see.

INTERACTIVE is t if called interactively.

(fn MANAGED-MAJOR-MODE PROJECT CLASS CONTACT &optional INTERACTIVE)" t nil)
             (eldoc-eval-expression "Eval expression with eldoc support in mode-line.

(fn)" t nil)
             (eldoc-in-minibuffer-mode "Show eldoc for current minibuffer input.

(fn &optional ARG)" t nil)
             (electric-spacing-mode "Toggle automatic surrounding space insertion (Electric Spacing mode).
With a prefix argument ARG, enable Electric Spacing mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

This is a local minor mode.  When enabled, typing an operator automatically
inserts surrounding spaces.  e.g., `=' becomes ` = ', `+=' becomes ` += '.
This is very handy for many programming languages.

(fn &optional ARG)" t nil)
             (elisp-benchmarks-run "Run all the benchmarks and present the results.
If non nil SELECTOR is a regexp to match the benchmark names to be executed.
The test is repeated RUNS number of times.  If RUNS is nil `elb-runs' is used as
default.
RECOMPILE all the benchmark folder when non nil.

(fn &optional SELECTOR RECOMPILE RUNS)" t nil)
             (enwc-register-backend "Register the backend KEY with DEFINITION.

Signals an error if a backend with KEY already exists and FORCEP is nil.

(fn DEFINITION &optional FORCEP)" nil nil)
             (enwc "The main front-end to ENWC.
This sets up the buffer and scans for networks.
In order to use this, one must have already run
`enwc-setup'.

\\{enwc-mode-map}" t nil)
             (epoch-view-mode "Visualize epoch (Unix) timestamps.

(fn &optional ARG)" t nil)
             (exco-org-show-day "Show meetings for the date specified by MONTH DAY YEAR.

(fn MONTH DAY YEAR)" nil nil)
             (excorporate-diary-enable "Enable Excorporate diary support." t nil)
             (exco-calfw-show-day "Show meetings for the date specified by MONTH DAY YEAR.

(fn MONTH DAY YEAR)" nil nil)
             (excorporate "Start Excorporate.
If `excorporate-configuration' is non-nil, use it without
prompting, otherwise prompt for Exchange account information, starting
with an email address.

Prefixed with one \\[universal-argument], always prompt for
Exchange account information for a new web service connection.
ARGUMENT is the prefix argument.

(fn &optional ARGUMENT)" t nil)
             (er/expand-region "Increase selected region by semantic units.

With prefix argument expands the region that many times.
If prefix argument is negative calls `er/contract-region'.
If prefix argument is 0 it resets point and mark to their state
before calling `er/expand-region' for the first time.

(fn ARG)" t nil)
             (filladapt-mode "Toggle Filladapt minor mode.
With arg, turn Filladapt mode on iff arg is positive.  When
Filladapt mode is enabled, auto-fill-mode and the fill-paragraph
command are both smarter about guessing a proper fill-prefix and
finding paragraph boundaries when bulleted and indented lines and
paragraphs are used.

(fn &optional ARG)" t nil)
             (fountain-mode "Major mode for screenwriting in Fountain markup.

(fn)" t nil)
             (frame-tabs-mode "Toggle display of a buffer tabs side window on each frame.
With a prefix argument ARG, enable this mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

When this mode is enabled, every normal frame is equipped with a
side window showing tabs for all buffers that appeared on that
frame.

(fn &optional ARG)" t nil)
             (frog-menu-read "Read from a menu of variable `frog-menu-type'.

PROMPT is a string with prompt information for the user.

COLLECTION is a list from which the user can choose an item. It
can be a list of strings or an alist mapping strings to return
values. Users can switch to `completing-read' from COLLECTION
using the TAB key. For sorting the displayed strings see
`frog-menu-sort-function'.

ACTIONS is an additional list of actions that can be given to let
the user choose an action instead an item from COLLECTION.

Each ACTION is a list of the form:

    (KEY DESCRIPTION RETURN)

Where KEY is a string to be interpreted as spelled-out
keystrokes, using the same format as for `kbd'.

DESCRIPTION is a string to be displayed along with KEY to
describe the action.

RETURN will be the returned value if KEY is pressed.

(fn PROMPT COLLECTION &optional ACTIONS)" nil nil)
             (frog-menu-call "Read a command from CMDS and execute it.

CMDS is a list of command symbols to choose from.  If PROMPT is
given it should be a string with prompt information for the
user.

(fn CMDS &optional PROMPT)" nil nil)
             (ggtags-try-complete-tag "A function suitable for `hippie-expand-try-functions-list'.

(fn OLD)" nil nil)
             (ggtags-build-imenu-index "A function suitable for `imenu-create-index-function'.

(fn)" nil nil)
             (ggtags-mode "Toggle Ggtags mode on or off.

If called interactively, enable Ggtags mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

\\{ggtags-mode-map}

(fn &optional ARG)" t nil)
             (ggtags-find-tag-dwim "Find NAME by context.
If point is at a definition tag, find references, and vice versa.
If point is at a line that matches `ggtags-include-pattern', find
the include file instead.

When called interactively with a prefix arg, always find
definition tags.

(fn NAME &optional WHAT)" t nil)
             (ggtags-find-project "

(fn)" nil nil)
             (gited-list-branches "List all branches or tags for the current repository.
Optional arg PATTERN if non-nil, then must be \"local\", \"remote\",
 or \"tags\".  That lists local branches, remote branches and tags,
 respectively.  When PATTERN is nil, then list the local branches.
Optional arg OTHER-WINDOW means to display the Gited buffer in another window.
Optional arg UPDATE if non-nil, then force to update the gited buffer.
 Otherwise, just switch to the Gited buffer if already exists.
When called interactively prompt for PATTERN.
When called interactively with a prefix set OTHER-WINDOW non-nil.

(fn &optional PATTERN OTHER-WINDOW UPDATE)" t nil)
             (gle-mode "Major mode to edit Graphics Layout Engine files.

(fn)" t nil)
             (gnome-c-style-mode "A minor-mode for editing GNOME-style C source code.

(fn &optional ARG)" t nil)
             (gnome-c-snippet-insert "

(fn COMMAND)" t nil)
             (gnome-c-snippet-insert-PackageClass "Insert the class name (in CamelCase) before the current point.

(fn PACKAGE CLASS)" t nil)
             (gnome-c-snippet-insert-PACKAGE_CLASS "Insert the class name before the current point.

(fn PACKAGE CLASS)" t nil)
             (gnome-c-snippet-insert-package_class "Insert the class name before the current point.

(fn PACKAGE CLASS)" t nil)
             (gnome-c-align-decls-region "Reformat function declarations in the region between BEG and END.

The `gnome-c-align-identifier-start-column',
`gnome-c-align-arglist-start-column', and
`gnome-c-align-arglist-identifier-start-column' variables
control the widths.

To set those variables, use \\[gnome-c-align-set-column],
\\[gnome-c-align-guess-columns], or
\\[gnome-c-align-guess-optimal-columns].

If they are not set, this function internally calls
\\[gnome-c-align-guess-optimal-columns] before formatting.

(fn BEG END)" t nil)
             (gnome-c-align-guess-columns "Guess the existing alignment rule from the declarations in BEG and END.

This sets `gnome-c-align-identifier-start-column',
`gnome-c-align-arglist-start-column', and
`gnome-c-align-arglist-identifier-start-column'.

(fn BEG END)" t nil)
             (gnome-c-align-guess-optimal-columns "Compute the optimal alignment rule from the declarations in BEG and END.

This sets `gnome-c-align-identifier-start-column',
`gnome-c-align-arglist-start-column', and
`gnome-c-align-arglist-identifier-start-column'.

(fn BEG END)" t nil)
             (gnome-c-align-set-column "Set alignment column of SYMBOL.

(fn SYMBOL)" t nil)
             (gnome-c-align-arglist-at-point "Reformat argument list at point, aligning argument to the right end.

(fn &optional IDENTIFIER-START-COLUMN)" t nil)
             (gnu-elpa-keyring-update "Import new GNU ELPA keys (if any) into package.el's keyring." nil nil)
             (gnugo-imgen-create-xpms "Return a list of XPM images suitable for BOARD-SIZE.
The size and style of the images are determined by
`gnugo-imgen-sizing-function' (rounded down to an even number)
and `gnugo-imgen-style', respectively.  See `gnugo-xpms'.

The returned list is cached; see also `gnugo-imgen-clear-cache'.

(fn BOARD-SIZE)" nil nil)
             (gnugo-frolic-in-the-leaves "Display the game tree in a *GNUGO Frolic* buffer.
This looks something like:

  1 B  --  E7    E7    E7    E7
  2 W  --  K10   K10   K10   K10
  3 B  --  E2    E2    E2    E2
  4 W  --  J3    J3    J3    J3
  5 B  --  A6    A6    A6    A6
  6 W  --  C9    C9    C9    C9
           │
           ├─────┬─────┐
           │     │     │
  7 B  --  H7   !B8    C8    C8
                       │
                       ├─────┐
                       │     │
  8 W  --  D9    D9    D9    E9
  9 B  --              H8    H8
 10 W  --              PASS  PASS
 11 B  --              H5    PASS
 12 W  --              PASS
 13 B  --             *PASS

with 0, 1, ... N (in this case N is 3) in the header line
to indicate the branches.  Branch 0 is the \"main line\".
Point (* in this example) indicates the current position,
\"!\" indicates comment properties (e.g., B8, branch 1),
and moves not actually on the game tree (e.g., E7, branch 3)
are dimmed.  Type \\[describe-mode] in that buffer for details.

(fn)" t nil)
             (gnugo "Run gnugo in a buffer, or resume a game in progress.
If there is already a game in progress you may resume it instead
of starting a new one.  Prefix arg means skip the game-in-progress
check and start a new game straight away.

Before starting, Emacs queries you for additional command-line
options (Emacs supplies \"--mode gtp --quiet\" automatically).

Note that specifying \"--infile FILENAME\" (or, \"-l FILENAME\")
silently clobbers certain other options, such as \"--color\".
For details, see info node `(gnugo) Invoking GNU Go'.

\\<gnugo-board-mode-map>
To play, use \\[gnugo-move] to place a stone or \\[gnugo-pass] to pass.
See `gnugo-board-mode' for a full list of commands.

(fn &optional NEW-GAME)" t nil)
             (gnus-mock-start "Start a new Emacs process, with the Gnus mock setup.
The new Emacs process will be started as \"-Q\", with the mock
Gnus settings pre-loaded.  Any of the normal Gnus entry points
will start a mock Gnus session." t nil)
             (gpastel-mode "Listen to GPaste events.

If called interactively, enable Gpastel mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (greader-speechd "greader speech-dispatcher back-end.

(fn COMMAND &optional ARG &rest _)" nil nil)
             (greader-espeak "back-end main function of greader-espeak.

(fn COMMAND &optional ARG &rest _)" nil nil)
             (guess-language-mode "Toggle guess-language mode.

If called interactively, enable Guess-Language mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Interactively with no argument, this command toggles the mode.
A positive prefix argument enables the mode, any other prefix
argument disables it.  From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

Guess-language is a buffer-local minor mode.  It guesses the
language of the current paragraph when flyspell detects an
incorrect word and changes ispell's dictionary and typo-mode
accordingly.  If the language settings change, flyspell is rerun
on the current paragraph.  If the paragraph is shorter than
`guess-language-min-paragraph-length', none of the above happens
because there is likely not enough text to guess the language
correctly.

(fn &optional ARG)" t nil)
             (make-heap "Create an empty heap with comparison function COMPARE-FUNCTION.

COMPARE-FUNCTION takes two arguments, A and B, and returns
non-nil or nil. To implement a max-heap, it should return non-nil
if A is greater than B. To implemenet a min-heap, it should
return non-nil if A is less than B.

Optional argument INITIAL-SIZE sets the initial size of the heap,
defaulting to 10. Optional argument RESIZE-FACTOR sets the factor
by which the heap's size is increased if it runs out of space,
defaulting to 2.

(fn COMPARE-FUNCTION &optional INITIAL-SIZE RESIZE-FACTOR)" nil nil)
             (hes-mode "Toggle highlighting of escape sequences.

If called interactively, enable Hes mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (turn-off-hes-mode "Turn off highlighting of escape sequences

(fn)" t nil)
             (turn-on-hes-mode "Turn on highlighting of escape sequences.

(fn)" t nil)
             (define-hook-function "Define FUNCTION to be a function, then add it to hooks.

The hooks to add are specified by the :hooks keyword.  This is a
simple list of hooks, unquoted, and the new function is added to
each one.

(fn FUNCTION ARGS &optional DOCSTRING &rest BODY)" nil t)
             (define-hook-helper "Define a hook helper for the variable HOOK-hook with ARGS as the argument list.

This helper consists of all the code in BODY.  HOOK should not be
quoted.  The keywords are:

:name    Specifies a name to use for the generated function.  As part
         of this macro, a function called hook-helper--HOOK will be
         created.  If NAME is given, then the function becomes
         ‘hook-helper--HOOK/NAME’.

:append  If non-nil, append the hook helper to the hook variable.

:suffix  Allows a user to specify that the hook variable doesn't
         end with ‘-hook’, but instead with another suffix, such as
         ‘-function’.  SUFFIX should be a string, and defaults to ‘hook’
         if not specified.  Note that SUFFIX is not assumed to start with
         a hyphen.

(fn HOOK ARGS &optional DOCSTRING &rest BODY)" nil t)
             (create-hook-helper "Creates a new hook helper ID for the hooks in HOOKS.

If a hook helper with id ID already exists, it's overridden.  All instances of
the helper in its associated hooks are replaced.

See `hkhlp-normalize-hook-spec' for an explanation of HOOKS.

(fn ID ARGS &optional DOCSTRING &keys HOOKS &rest BODY)" nil t)
             (defhydra "Create a Hydra - a family of functions with prefix NAME.

NAME should be a symbol, it will be the prefix of all functions
defined here.

BODY has the format:

    (BODY-MAP BODY-KEY &rest BODY-PLIST)

DOCSTRING will be displayed in the echo area to identify the
Hydra.  When DOCSTRING starts with a newline, special Ruby-style
substitution will be performed by `hydra--format'.

Functions are created on basis of HEADS, each of which has the
format:

    (KEY CMD &optional HINT &rest PLIST)

BODY-MAP is a keymap; `global-map' is used quite often.  Each
function generated from HEADS will be bound in BODY-MAP to
BODY-KEY + KEY (both are strings passed to `kbd'), and will set
the transient map so that all following heads can be called
though KEY only.  BODY-KEY can be an empty string.

CMD is a callable expression: either an interactive function
name, or an interactive lambda, or a single sexp (it will be
wrapped in an interactive lambda).

HINT is a short string that identifies its head.  It will be
printed beside KEY in the echo erea if `hydra-is-helpful' is not
nil.  If you don't even want the KEY to be printed, set HINT
explicitly to nil.

The heads inherit their PLIST from BODY-PLIST and are allowed to
override some keys.  The keys recognized are :exit and :bind.
:exit can be:

- nil (default): this head will continue the Hydra state.
- t: this head will stop the Hydra state.

:bind can be:
- nil: this head will not be bound in BODY-MAP.
- a lambda taking KEY and CMD used to bind a head.

It is possible to omit both BODY-MAP and BODY-KEY if you don't
want to bind anything.  In that case, typically you will bind the
generated NAME/body command.  This command is also the return
result of `defhydra'.

(fn NAME BODY &optional DOCSTRING &rest HEADS)" nil t)
             (ivy-explorer-mode "Globally enable `ivy-explorer' for file navigation.

If called interactively, enable Ivy-Explorer mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

`ivy-explorer-mode' is a global minor mode which changes
`read-file-name-function' which is used for file completion.

When `ivy-explorer-enable-counsel-explorer' (by default it is),
`find-file' and `counsel-find-file' will be remapped to
`counsel-explorer.', too.

See `ivy-explorer-map' for bindings used in the minibuffer.

(fn &optional ARG)" t nil)
             (javaimp-organize-imports "Groups import statements according to the value of
`javaimp-import-group-alist' (which see) and prints resulting
groups leaving one blank line between groups.

If the file already contains some import statements, this command
rewrites them, starting with the same place.  Else, if the the
file contains package directive, this command inserts one blank
line below and then imports.  Otherwise, imports are inserted at
the beginning of buffer.

Classes within a single group are ordered in a lexicographic
order.  Imports not matched by any regexp in `javaimp-import-group-alist'
are assigned a default order defined by
`javaimp-import-default-order'.

NEW-IMPORTS is a list of additional imports; each element should
be of the form (CLASS . TYPE), where CLASS is a string and TYPE
is `ordinary' or `static'.  Interactively, NEW-IMPORTS is nil.

(fn &rest NEW-IMPORTS)" t nil)
             (javaimp-add-import "Imports classname in the current file.  Interactively,
asks for a class to import, adds import statement and calls
`javaimp-organize-imports'.  Import statements are not
duplicated.  Completion alternatives are constructed based on
this module's dependencies' classes, JDK classes and top-level
classes in the current module.

(fn CLASSNAME)" t nil)
             (javaimp-visit-project "Loads a project and its submodules.  DIR should point to a
directory containing pom.xml / build.gradle[.kts].

After being processed by this command, the module tree becomes
known to javaimp and `javaimp-add-import' may be called inside
any module file.

(fn DIR)" t nil)
             (jgraph-mode "A major mode for editing Jgraph files.

(fn)" t nil)
             (js2-jsx-mode "Major mode for editing JSX code.

To customize the indentation for this mode, set the SGML offset
variables (`sgml-basic-offset' et al) locally, like so:

  (defun set-jsx-indentation ()
    (setq-local sgml-basic-offset js2-basic-offset))
  (add-hook \\='js2-jsx-mode-hook #\\='set-jsx-indentation)

(fn)" t nil)
             (js2-mode "Major mode for editing JavaScript code.

(fn)" t nil)
             (js2-minor-mode "Minor mode for running js2 as a background linter.
This allows you to use a different major mode for JavaScript editing,
such as `js-mode', while retaining the asynchronous error/warning
highlighting features of `js2-mode'.

If called interactively, enable Js2 minor mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (js2-highlight-unused-variables-mode "Toggle highlight of unused variables.

If called interactively, enable Js2-Highlight-Unused-Variables mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (js2-imenu-extras-mode "Toggle Imenu support for frameworks and structural patterns.

(fn &optional ARG)" t nil)
             (js2-imenu-extras-setup "

(fn)" nil nil)
             (json-mode "Major mode for editing JavaScript Object Notation (JSON) data files.

(fn)" t nil)
             (jumpc "Initialize jump cursor.

(fn)" t nil)
             (landmark "Start or resume an Landmark game.
If a game is in progress, this command allows you to resume it.
Here is the relation between prefix args and game options:

prefix arg | robot is auto-started | weights are saved from last game
---------------------------------------------------------------------
none / 1   | yes                   | no
       2   | yes                   | yes
       3   | no                    | yes
       4   | no                    | no

You start by moving to a square and typing \\[landmark-start-robot],
if you did not use a prefix arg to ask for automatic start.
Use \\[describe-mode] for more info.

(fn PARG)" t nil)
             (landmark-test-run "Run 100 Landmark games, each time saving the weights from the previous game.

(fn)" t nil)
             (leaf "Symplify your `.emacs' configuration for package NAME with ARGS.

(fn NAME &rest ARGS)" nil t)
             (leaf-expand "Expand `leaf' at point." t nil)
             (leaf-create-issue-template "Create issue template buffer." t nil)
             (leaf-pp "Output the pretty-printed representation of leaf SEXP.

(fn SEXP)" nil nil)
             (leaf-pp-to-string "Return format string of `leaf' SEXP like `pp-to-string'.

(fn SEXP)" nil t)
             (leaf-available-keywords "Return current available `leaf' keywords list." t nil)
             (lex-parse-re "Parse STRING as a regular expression.
LEXER specifies the regexp syntax to use.  It can be `ere', or `bre'
and it defaults to `bre'.

(fn STRING &optional LEXER)" nil nil)
             (lex-compile "Compile a set of regular expressions.
ALIST is a list of elements of the form (REGEXP . VALUE).
The compiled automaton will match all those regexps at the same time
and will return the VALUE fof the leftmost longest match.

Each REGEXP object should be in the sexp form described in the
Commentary section.

(fn ALIST)" nil nil)
             (lmc-asm-mode "Major mode to edit LMC assembly code.

(fn)" t nil)
             (load-dirs-reload "Load all Emacs Lisp files in `load-dirs'.
Clears the list of loaded files and just calls `load-dir-load'.

(fn)" t nil)
             (load-dirs "Load all Emacs Lisp files in `load-dirs'.
Will not load a file twice (use `load-dir-reload' for that).
Recurses into subdirectories if `load-dir-recursive' is t.

(fn)" t nil)
             (provide-me "Call `provide' with the feature's symbol name made from
source-code's file basename sans extension.  For example if you
write (provide-me) inside file ~/lisp/foo.el, this is the same as
writing: (provide \\='foo).

With a prefix, that prefix is prepended to the `provide' So in
the previous example, if you write (provide-me \"bar-\") this is the
same as writing (provide \\='bar-foo).

(fn &optional PREFIX)" nil t)
             (require-relative-list "Run `require-relative' on each name in LIST which should be a list of
strings, each string being the relative name of file you want to run.

(fn LIST &optional OPT-PREFIX)" nil t)
             (require-relative "Run `require' on an Emacs Lisp file relative to the Emacs Lisp code
that is in the process of being loaded or eval'd.  The symbol used in require
is the base file name (without directory or file extension) treated as a
symbol.

WARNING: it is best to to run this function before any
buffer-setting or buffer changing operations.

(fn RELATIVE-FILE &optional OPT-FILE OPT-PREFIX)" nil nil)
             (load-relative "Load an Emacs Lisp file relative to Emacs Lisp code that is in
the process of being loaded or eval'd.

FILE-OR-LIST is either a string or a list of strings containing
files that you want to loaded.  If SYMBOL is given, the location of
of the file of where that was defined (as given by `symbol-file' is used
if other methods of finding __FILE__ don't work.

(fn FILE-OR-LIST &optional SYMBOL)" nil nil)
             (with-relative-file "Read the relative FILE into a temporary buffer and evaluate BODY
in this buffer.

(fn FILE &rest BODY)" nil t)
             (find-file-noselect-relative "Read relative FILENAME into a buffer and return the buffer.
If a buffer exists visiting FILENAME, return that one, but
verify that the file has not changed since visited or saved.
The buffer is not selected, just returned to the caller.
Optional second arg NOWARN non-nil means suppress any warning messages.
Optional third arg RAWFILE non-nil means the file is read literally.
Optional fourth arg WILDCARDS non-nil means do wildcard processing
and visit all the matching files.  When wildcards are actually
used and expanded, return a list of buffers that are visiting
the various files.

(fn FILENAME &optional NOWARN RAWFILE WILDCARDS)" nil nil)
             (__FILE__ "Return the string name of file/buffer that is currently begin executed.

The first approach for getting this information is perhaps the
most pervasive and reliable.  But it the most low-level and not
part of a public API, so it might change in future
implementations.  This method uses the name that is recorded by
readevalloop of `lread.c' as the car of variable
`current-load-list'.

Failing that, we use `load-file-name' which should work in some
subset of the same places that the first method works.  However
`load-file-name' will be nil for code that is eval'd.  To cover
those cases, we try function `buffer-file-name' which is initially
correct, for eval'd code, but will change and may be wrong if the
code sets or switches buffers after the initial execution.

As a last resort, you can pass in SYMBOL which should be some
symbol that has been previously defined if none of the above
methods work we will use the file-name value find via
`symbol-file'.

(fn &optional SYMBOL)" nil nil)
             (loccur "Perform a simple grep in current buffer.

This command hides all lines from the current buffer except those
containing the regular expression REGEX.  A second call of the function
unhides lines again.

When called interactively, either prompts the user for REGEXP or,
when called with an active region, uses the content of the
region, unless called with the universal prefix (C-u)

(fn REGEX)" t nil)
             (loccur-current "Call `loccur' for the current word." t nil)
             (markchars-global-mode "Toggle Markchars mode in all buffers.
With prefix ARG, enable Markchars-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Markchars mode is enabled in all buffers where
`(lambda nil (markchars-mode 1))' would do it.
See `markchars-mode' for more information on Markchars mode.

(fn &optional ARG)" t nil)
             (markchars-mode "Mark special characters.
Which characters to mark are defined by `markchars-pattern'.

If called interactively, enable Markchars mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

The default is to mark nonascii chars with a magenta underline.

(fn &optional ARG)" t nil)
             (memory-usage "List all buffers and their memory usage.

(fn)" t nil)
             (metar "Display recent weather information.
If a prefix argument is given, prompt for country and station name.
If two prefix arguments are given, prompt for exact station code.
Otherwise, determine the best station via latitude/longitude.

(fn &optional ARG)" t nil)
             (midikbd-open "Open the raw Midi device FILE as a source for Midi input.
This should be an ALSA device like \"/dev/snd/midiC1D0\".  If your
Midi producing device is a software Midi device, you might need to
call

    sudo modprobe snd-virmidi

in order to have some virtual ALSA ports available as such raw Midi
devices.

(fn FILE)" t nil)
             (mines "Play the minesweeper game.
Called with a prefix prompt for the difficulty level.

(fn &optional ARG)" t nil)
             (minibuffer-line-mode "Display status info in the minibuffer window.

(fn &optional ARG)" t nil)
             (minimap-mode "Toggle minimap mode.

If called interactively, enable Minimap mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (mmm-add-classes "Add the submode classes CLASSES to `mmm-classes-alist'.

(fn CLASSES)" nil nil)
             (nxml-web-mode "

(fn)" t nil)
             (html-erb-mode "

(fn)" t nil)
             (multishell-list "Edit your current and historic list of shell buffers.

If optional COMPLETING is nil, we present the full
`multishell-history' list in a popped buffer named `*Shells*'.

In the buffer, hit ? or h for a list of commands.

When optional COMPLETING is non-nil, it must be a list of
multishell-history completion candidate entries, as provided by
`completing-read'. Then we present the list as a part of
minibuffer completion.

You can get to the shells listing by recursively invoking
\\[multishell-pop-to-shell] at the `multishell-pop-to-shell'
`universal-argument' prompts.

(fn &optional COMPLETING)" t nil)
             (multishell-pop-to-shell "Easily navigate to and within multiple shell buffers, local and remote.

Use a single `universal-argument' (\\[universal-argument]) to launch and choose between
nalternate shell buffers, and a doubled universal argument to also set your
choice as the ongoing default.  Append a path to a new shell name to launch
a shell in that directory, and use Emacs tramp syntax to launch a remote
shell. There is a shortcut to manage your list of current and
historical shells, collectively, using `multishell-list' - see below.

Customize-group `multishell' to set up a key binding and tweak behaviors.

Manage your collection of current and historical shells by
recursively invoking \\[multishell-pop-to-shell] at the
`multishell-pop-to-shell' universal argument prompts, eg:

  \\[universal-argument] \\[multishell-pop-to-shell] \\[multishell-pop-to-shell]

(That will be just a few keys if you do the above
customization.) Hit ? in the listing buffer for editing commands.

==== Basic operation:

 - If the current buffer is shell-mode (or shell-mode derived)
   buffer then focus is moved to the process input point.

   (You can use a universal argument go to a different shell
   buffer when already in a buffer that has a process - see
   below.)

 - If not in a shell buffer (or with universal argument), go to a
   window that is already showing the (a) shell buffer, if any.

   In this case, the cursor is left in its prior position in the
   shell buffer. Repeating the command will then go to the
   process input point, per the first item in this list.

   We respect `pop-up-windows', so you can adjust it to set the
   other-buffer/same-buffer behavior.

 - Otherwise, start a new shell buffer, using the current
   directory as the working directory.

If a buffer with the resulting name exists and its shell process
was disconnected or otherwise stopped, it's resumed.

===== Universal arg to start and select between named shell buffers:

You can name alternate shell buffers to create or return to, by
prefixing your \\[multishell-pop-to-shell] invocation with single or double
`universal-argument', \\[universal-argument]:

 - With a single universal argument, prompt for the buffer name
   to use (without the asterisks that shell mode will put around
   the name), defaulting to `shell'.

   Completion is available.

   This combination makes it easy to start and switch across
   multiple shell restarts.

 - A double universal argument will prompt for the name *and* set
   the default to that name, so the target shell becomes the
   primary.

   See `multishell-primary-name' for info about preserving the
   setting across emacs restarts.

 - Manage your collection of current and historical shells by
   recursively invoking \\[multishell-pop-to-shell] at either of the
   `multishell-pop-to-shell' universal argument prompts, or at any
   time via \\[multishell-list]. Hit ? in the listing buffer for
   editing commands.

===== Select starting directory and remote host:

The shell buffer name you give to the prompt for a universal arg
can include an appended path. That will be used for the startup
directory. You can use tramp remote syntax to specify a remote
shell. If there is an element after a final `/', that's used for
the buffer name. Otherwise, the host, domain, or path is used.

For example:

* `#root/sudo:root@localhost:/etc' for a buffer named \"*#root*\" with a
  root shell starting in /etc.

* `/ssh:example.net:' for a shell buffer in your homedir on example.net.
  The buffer will be named \"*example.net*\".

* `#ex/ssh:example.net|sudo:root@example.net:/var/log' for a root shell
  starting in /var/log on example.net named \"*#ex*\".

* `interior/ssh:gateway.corp.com|ssh:interior.corp.com:' to go
  via gateway.corp.com to your homedir on interior.corp.com.  The
  buffer will be named \"*interior*\". You could append a sudo
  hop to the path, combining the previous example, and so on.

File visits from the shell, and many common emacs activities like
dired, will be on the host where the shell is running, in the
auspices of the target account, and relative to the current
directory.

You can change the startup path for a shell buffer by editing it
at the completion prompt. The new path will not take effect for
an already-running shell.

To remove a shell buffer's history entry, kill the buffer and
affirm removal of the entry when prompted.

===== Activate savehist to retain shell buffer names and paths across Emacs restarts:

To have emacs maintain your history of shell buffer names and paths,
customize the savehist group to activate savehist.

(fn &optional ARG NAME HERE)" t nil)
             (nameless-mode "Toggle Nameless mode on or off.
With a prefix argument ARG, enable Nameless mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{nameless-mode-map}

(fn &optional ARG)" t nil)
             (define-namespace "Inside the namespace NAME, execute BODY.
NAME can be any symbol (not quoted), but it's highly recommended
to use some form of separator (such as :, /, or -).  For a
complete description of this macro, please visit the frontpage
with \\[names-view-manual].

In summary, this macro has two main effects:

1. Any definitions inside BODY will have NAME prepended to the
symbol given.  Ex:

    (define-namespace foo-
    (defvar bar 1 \"docs\")
    )

expands to

    (defvar foo-bar 1 \"docs\")


2. Any function calls and variable names get NAME prepended to
them if such a variable or function exists.  Ex:

    (define-namespace foo:
    (defun message (x y) nil)
    (message \"%s\" my-var)
    )

expands to

    (defun foo:message (x y) nil)
    (foo:message \"%s\" my-var)

Note how `message' is expanded to `foo:message' in the second
form, because that function exists.  Meanwhile, `bar' is left
untouched because `foo:bar' is not a known variable name.

===============================

AUTOLOAD

In order for `define-namespace' to work with \";;;###autoload\"
comments must replace all instances of \";;;###autoload\" inside
your `define-namespace' with `:autoload'.
Afterwards, add an \";;;###autoload\" comment just above your
`define-namespace'.

===============================

KEYWORDS

Immediately after NAME you may add keywords which customize the
behaviour of `define-namespace'. For a list of possible keywords
and a description of their effects, see the variable
`names--keyword-list'.

(fn NAME [KEYWORD ...] BODY)" nil t)
             (nhexl-mode "Minor mode to edit files via hex-dump format

If called interactively, enable Nhexl mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (global-nlinum-mode "Toggle Nlinum mode in all buffers.
With prefix ARG, enable Global Nlinum mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Nlinum mode is enabled in all buffers where
`(lambda nil (unless (minibufferp) (nlinum-mode)))' would do it.
See `nlinum-mode' for more information on Nlinum mode.

(fn &optional ARG)" t nil)
             (nlinum-mode "Toggle display of line numbers in the left margin (Linum mode).
With a prefix argument ARG, enable Linum mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

Linum mode is a buffer-local minor mode.

(fn &optional ARG)" t nil)
             (notes-w3-follow-link-mouse "* Follow the URL where the mouse is.

(fn E)" t nil)
             (notes-w3-follow-link "* Follow the URL at the point.
Takes a PT to look at and a WHERE to open the URL (`otherwindow' or nil).
This code works hard to recognize URLs based on context information.
URLs can be quoted by whitespace, beginning and end of lines,
or the official < and >.

As a special case we also recognize (and skip) the text \"prev:\"
and \"next:\" before the URL.  Notes-mode uses these fields to link
entries.

(fn PT &optional WHERE)" t nil)
             (notes-w3-url "Open a notes-url.  Handle simple URLs here, or call notes-w3-alternate-url.
Takes the URL as an argument.  Optionally you specify
WHERE the information should appear (either `otherwindow' or nil,
defaults to nil).
BEST-EFFORT causes notes-w3-url allows the tag portion of the URL to not
match.  If there's no tag match, it looks for the nearest matching prefix.

URLs optionally can begin with an URL: tag, which will be ignored.

notes-w3-url handles only <file://localhost/...> (or <file:///...>) URLs.
Other URLs it hands off to the routine in notes-w3-alternate-url
for processing.  If you use w3-mode, then
    (setq notes-w3-alternate-url \\='w3-follow-link)
will have w3 handle tough URLs.

(fn URL &optional WHERE BEST-EFFORT)" nil nil)
             (notes-mode "Enable notes-mode for a buffer.

Inside a notes buffer one can click on URLs and follow them to
other notes files.

See the file notes-variables.el for all customization options.
To change options, (require \\='notes-variables) in your .emacs
and then change things.

Subjects in notes mode are lines beginning with an asterisk
and underlined with dashes.  Subjects can be completed
with \\[notes-complete-subject] and are automatically underlined.

You may wish to add this code to your .emacs file:
    (add-to-list \\='auto-mode-alist
      (cons \"/9[0-9][0-9][0-9][0-9][0-9].?\\\\\\='\" \\='notes-mode))
    (define-key global-map [?\\C-c ?n] \\='notes-index-todays-link)
to automatically enter notes mode.

I have two suggestions for how to organize your notes files.
First, I collect my notes into a separate file per day.  (If you have
fewer notes, you may find once-per-week or month more suitable.)
Second, at the beginning of each file I have a subject \"* Today\".
Since every file has this subject, I can use its prev and next links
to easily move around the collection of files.

The key-bindings of this mode are:
\\{notes-mode-map}

(fn)" t nil)
             (notes-underline-line "* Create a row of dashes as long as this line, or adjust the current underline.

(fn)" t nil)
             (notes-index-mode "Notes-index-mode with mouse support.

You may wish to change notes-bold-face and notes-use-font-lock.

There should be no need to add notes-index-mode to auto-mode-alist
since the index generation functions add code to the index file
which invokes notes-index-mode.

Key bindings are:
\\{notes-index-mode-map}

(fn)" t nil)
             (notes-index-todays-link "* Open the notes file for today.

(fn)" t nil)
             (notes-format-date "Format the TIME up to be a notes-format date.
If no TIME is specified, use today's date.

(fn &optional TIME)" nil nil)
             (global-num3-mode "Toggle Num3 mode in all buffers.
With prefix ARG, enable Global Num3 mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Num3 mode is enabled in all buffers where
`num3-mode' would do it.
See `num3-mode' for more information on Num3 mode.

(fn &optional ARG)" t nil)
             (num3-mode "Toggle num3 minor mode in the current buffer.
Num3 minor mode makes long numbers more readable by highlighting
groups of digits when font-lock mode is enabled.

If a number is longer than `num3-threshold', the mode will split
it into a group of `num3-group-size' (if number is decimal) or
four (if number is hexadecimal or binary) digits.

Hexadecimal numbers are recognised by \"0x\" or \"#x\"
prefix (case insensitive) and binary numbers by \"0b\" or \"#b\"
prefix.  (There is no special handling for octal numbers –
starting with \"0o\" or \"#o\" – and instead they are handled
like decimal numbers).

Decimal fractions are recognised as well and grouped from the
beginning rathar then the end.  For instance, with group size of
three, a number \"12345.12345\" will be split into groups as
follows: \"12|345.123|45\".  Fractions without integer part are
also recognised, eg. \".12345\".

Groups are highlighted alternately using `num3-face-odd' and
`num3-face-even' faces.  `num3-face-odd' face (which is empty by
default) is the one used for the group closest to the decimal
point, i.e. groups are counted starting with one outwards from
the (place where) decimal point (would be) is.

(fn &optional ARG)" t nil)
             (oauth2-url-retrieve "Retrieve an URL asynchronously using TOKEN to access it.
TOKEN can be obtained with `oauth2-auth'.  CALLBACK gets called with CBARGS
when finished.  See `url-retrieve'.

(fn TOKEN URL CALLBACK &optional CBARGS REQUEST-METHOD REQUEST-DATA REQUEST-EXTRA-HEADERS)" nil nil)
             (oauth2-url-retrieve-synchronously "Retrieve an URL synchronously using TOKEN to access it.
TOKEN can be obtained with `oauth2-auth'.

(fn TOKEN URL &optional REQUEST-METHOD REQUEST-DATA REQUEST-EXTRA-HEADERS)" nil nil)
             (oauth2-auth-and-store "Request access to a resource and store it using `plstore'.

(fn AUTH-URL TOKEN-URL SCOPE CLIENT-ID CLIENT-SECRET &optional REDIRECT-URI STATE)" nil nil)
             (oauth2-auth "Authenticate application via OAuth2.

(fn AUTH-URL TOKEN-URL CLIENT-ID CLIENT-SECRET &optional SCOPE STATE REDIRECT-URI)" nil nil)
             (oauth2-refresh-access "Refresh OAuth access TOKEN.
TOKEN should be obtained with `oauth2-request-access'.

(fn TOKEN)" nil nil)
             (olivetti-mode "Olivetti provides a nice writing environment.

If called interactively, enable Olivetti mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

Window margins are set to relative widths to accomodate a text
body width set with `olivetti-body-width'.

(fn &optional ARG)" t nil)
             (omn-mode "Major mode for editing OWL Manchester Notation.

This is a format for specifying OWL ontologies, that is designed
to be easy to type and to read. It is fully documented and
specified at http://www.w3.org/TR/owl2-manchester-syntax/

(fn)" t nil)
             (on-screen-global-mode "Global minor mode guiding your eyes while scrolling.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.

You can make use of `on-screen-inhibit-highlighting' to prevent
highlighting on a per-buffer basis.

Type M-x customize-group on-screen RET for configuration.

(fn &optional ARG)" t nil)
             (on-screen-mode "Buffer local minor mode guiding your eyes while scrolling.
With a prefix argument ARG, enable the mode if ARG is positive,
and disable it otherwise.  If called from Lisp, enable the mode
if ARG is omitted or nil.
Type M-x customize-group on-screen RET for configuration.

(fn &optional ARG)" t nil)
             (org-edna-mode "Toggle Org Edna mode.

If called interactively, enable Org-Edna mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (org-edna--unload "Unload Org Edna.

Remove Edna's workers from `org-trigger-hook' and
`org-blocker-hook'." nil nil)
             (org-edna--load "Setup the hooks necessary for Org Edna to run.

This means adding to `org-trigger-hook' and `org-blocker-hook'." nil nil)
             (orgalist-mode "Toggle Org-like lists and their relative commands.

With a prefix argument ARG, enable Auto Fill mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

When Orgalist mode is enabled, any line beginning with \"-\",
\"+\", \"1.\" or \"a.\" followed by a space starts a list.  You
can then operate locally on the list, e.g., to insert new items,
move items or sort them.  See below for details.

Moreover, you can add check-boxes to items

  - [ ] A checkbox, toggled with `C-c C-c'

turn an unordered list into a description list

  - term :: description

and control numbering in an ordered list

  4. [@4] a forced numbered item

key             binding
---             -------
M-<RET>         `orgalist-insert-item'
M-<UP>          `orgalist-previous-item'
M-<DOWN>        `orgalist-next-item'
M-S-<UP>        `orgalist-move-item-up'
M-S-<DOWN>      `orgalist-move-item-down'
M-<LEFT>        `orgalist-outdent-item'
M-<RIGHT>       `orgalist-indent-item'
M-S-<LEFT>      `orgalist-outdent-item-tree'
M-S-<RIGHT>     `orgalist-indent-item-tree'
C-c -           `orgalist-cycle-bullet'
C-c ^           `orgalist-sort-items'
C-c C-c         `orgalist-check-item'

(fn &optional ARG)" t nil)
             (osc-make-server "Create an OSC server which listens on HOST and PORT.
DEFAULT-HANDLER is a function with arguments (path &rest args) which is called
when a new OSC message arrives.  See `osc-server-set-handler' for more
fine grained control.
A process object is returned which can be dicarded with `delete-process'.

(fn HOST PORT DEFAULT-HANDLER)" nil nil)
             (osc-send-message "Send an OSC message from CLIENT to the specified PATH with ARGS.

(fn CLIENT PATH &rest ARGS)" nil nil)
             (osc-make-client "Create an OSC client process which talks to HOST and PORT.

(fn HOST PORT)" nil nil)
             (other-frame-window-mode "Minor mode for other frame/window buffer placement.
Enable mode if ARG is positive.

\\[ofw-other-window] <command> causes a buffer displayed by <command>
to appear in another window in the same frame; a window
is created if necessary.

\\[ofw-other-frame] <command> causes a buffer displayed by <command>
to appear in another frame; a frame is created if necessary.

\\[ofw-move-to-other-window] moves the current buffer to another
window in the same frame.

\\[ofw-move-to-other-frame] moves the current buffer to another
frame.

In addition, \\[ofw-other-window] and \\[ofw-other-frame] can be followed by these keys:

0 - deletes the current window/frame

1 - deletes the other windows/frames.

2 - shows another view of the current buffer in a new
    window/frame.

a - creates a commit log entry for the current defun in
    another window/frame.

b - switches to another buffer in another window/frame.

d - start dired in another window/frame.

f - find-file in another window/frame.

m - compose mail in another window/frame.

o - select another window/frame.

r - find-file-read-only in another window/frame.

(fn &optional ARG)" t nil)
             (global-pabbrev-mode "Toggle Pabbrev mode in all buffers.
With prefix ARG, enable Global Pabbrev mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Pabbrev mode is enabled in all buffers where
`pabbrev-global-mode' would do it.
See `pabbrev-mode' for more information on Pabbrev mode.

(fn &optional ARG)" t nil)
             (pabbrev-mode "Toggle pabbrev mode.
With arg, turn on Predicative Abbreviation mode if and only if arg is
positive.

This mode is another abbreviation expansion mode somewhat like
`dabbrev-expand', in that it looks through the current buffer for
symbols that can complete the current symbol. Unlike `dabbrev-expand',
it does this by discovering the words during the Emacs idle time, and
places the results into data structures which enable very rapid
extraction of expansions. The upshot of this is that it can offer
suggestions as you type, without causing an unacceptable slow down.

There is an associated `global-pabbrev-mode' which turns on the mode
on in all buffers.

(fn &optional ARG)" t nil)
             (paced-repopulate-current-dictionary-async "Repopulate current dictionary from its population commands, asynchronously.

Population commands are stored in the field of the same name.

Note that this will empty the dictionary's contents.

(fn)" t nil)
             (paced-repopulate-named-dictionary-async "Repopulate dictionary named KEY from its population commands, asynchronously.

Population commands are stored in the field of the same name.

Note that this will empty the dictionary's contents.

(fn KEY)" t nil)
             (paced-load-all-dictionaries "Load all dictionaries in `paced-dictionary-directory'.

(fn)" t nil)
             (phps-mode-format-buffer "Format current buffer according to PHPs mode." t nil)
             (phps-mode-flycheck-setup "Setup `flycheck' for `phps-mode'." nil nil)
             (phps-mode-rescan-buffer "Re-scan buffer." t nil)
             (pinentry-start "Start a Pinentry service.

Once the environment is properly set, subsequent invocations of
the gpg command will interact with Emacs for passphrase input.

If the optional QUIET argument is non-nil, messages at startup
will not be shown.

(fn &optional QUIET)" t nil)
             (poker "Play a game of texas hold 'em poker.

(fn INITIAL-STACK MIN-BET PLAYERS)" t nil)
             (posframe-delete-all "Delete all posframe frames and buffers." t nil)
             (posframe-hide-all "Hide all posframe frames." t nil)
             (posframe-show "Pop up a posframe and show STRING at POSITION.

POSITION can be:
1. An integer, meaning point position.
2. A cons of two integers, meaning absolute X and Y coordinates.
3. Other type, in which case the corresponding POSHANDLER should be
   provided.

POSHANDLER is a function of one argument returning an actual
position.  Its argument is a plist of the following form:

  (:position xxx
   :position-info xxx
   :poshandler xxx
   :font-height xxx
   :font-width xxx
   :posframe xxx
   :posframe-width xxx
   :posframe-height xxx
   :posframe-buffer xxx
   :parent-frame xxx
   :parent-window-left xxx
   :parent-window-top xxx
   :parent-frame-width xxx
   :parent-frame-height xxx
   :parent-window xxx
   :parent-window-width  xxx
   :parent-window-height xxx
   :minibuffer-height
   :mode-line-height
   :header-line-height
   :tab-line-height
   :x-pixel-offset xxx
   :y-pixel-offset xxx)

By default, poshandler is auto-selected based on the type of POSITION,
but the selection can be overridden using the POSHANDLER argument.
The builtin poshandler functions are listed below:

1.  `posframe-poshandler-frame-center'
2.  `posframe-poshandler-frame-top-center'
3.  `posframe-poshandler-frame-top-left-corner'
4.  `posframe-poshandler-frame-top-right-corner'
5.  `posframe-poshandler-frame-bottom-center'
6.  `posframe-poshandler-frame-bottom-left-corner'
7.  `posframe-poshandler-frame-bottom-right-corner'
8.  `posframe-poshandler-window-center'
9.  `posframe-poshandler-window-top-center'
10. `posframe-poshandler-window-top-left-corner'
11. `posframe-poshandler-window-top-right-corner'
12. `posframe-poshandler-window-bottom-center'
13. `posframe-poshandler-window-bottom-left-corner'
14. `posframe-poshandler-window-bottom-right-corner'
15. `posframe-poshandler-point-top-left-corner'
16. `posframe-poshandler-point-bottom-left-corner'

This posframe's buffer is BUFFER-OR-NAME, which can be a buffer
or a name of a (possibly nonexistent) buffer.

If NO-PROPERTIES is non-nil, The STRING's properties will
be removed before being shown in posframe.

Posframe's frame size can be set by WIDTH and HEIGHT.
If one of them is nil, posframe's frame size will fit the
buffer.  MIN-WIDTH and MIN-HEIGTH can be useful to prevent
posframe becoming too small.

If LEFT-FRINGE or RIGHT-FRINGE is a number, left fringe or
right fringe with be shown with the specified width.

By default, posframe shows no borders, but users can specify
borders by setting INTERNAL-BORDER-WIDTH to a positive number.
Border color can be specified by INTERNAL-BORDER-COLOR
or via the ‘internal-border’ face.

Posframe's font as well as foreground and background colors are
derived from the current frame by default, but can be overridden
using the FONT, FOREGROUND-COLOR and BACKGROUND-COLOR arguments,
respectively.

By default, posframe will display no header-line or mode-line.
In case a header-line or mode-line is desired, users can set
RESPECT-HEADER-LINE or RESPECT-MODE-LINE to t.

INITIALIZE is a function with no argument.  It will run when
posframe buffer is first selected with `with-current-buffer'
in `posframe-show', and only run once (for performance reasons).
If INITIALIZE is nil, `posframe-default-initialize-function' will
be used as fallback; this variable can be used to set posframe
buffer gobally.

OVERRIDE-PARAMETERS is very powful, *all* the frame parameters
used by posframe's frame can be overridden by it.

TIMEOUT can specify the number of seconds after which the posframe
will auto-hide.

If REFRESH is a number, posframe's frame-size will be re-adjusted
every REFRESH seconds.

You can use `posframe-delete-all' to delete all posframes.

(fn BUFFER-OR-NAME &key STRING POSITION POSHANDLER WIDTH HEIGHT MIN-WIDTH MIN-HEIGHT X-PIXEL-OFFSET Y-PIXEL-OFFSET LEFT-FRINGE RIGHT-FRINGE INTERNAL-BORDER-WIDTH INTERNAL-BORDER-COLOR FONT FOREGROUND-COLOR BACKGROUND-COLOR RESPECT-HEADER-LINE RESPECT-MODE-LINE INITIALIZE NO-PROPERTIES KEEP-RATIO OVERRIDE-PARAMETERS TIMEOUT REFRESH &allow-other-keys)" nil nil)
             (posframe-workable-p "Test posframe workable status." nil nil)
             (style-format "

(fn)" t nil)
             (xml-mode "Major mode for editing XML, specialized from SGML mode.
Sets various variables appropriately for XML.

Can be used without a DTD.  In that case, warnings about undefined
elements and entities are suppressed and various commands' behaviour
is modified to account for the lack of information.  For instance, the
element names offered for selection or completion are those in the
parse of the document, but other names may be entered.

Note that without a DTD, indenting lines will only work if
`sgml-indent-data' is non-nil.

(fn)" t nil)
             (sgml-mode "Major mode for editing SGML.
\\<sgml-mode-map>Makes > display the matching <.  Makes / display matching /.
Use \\[sgml-validate] to validate your document with an SGML parser.

You can find information with:
\\[sgml-show-context]  Show the nesting of elements at cursor position.
\\[sgml-list-valid-tags]  Show the tags valid at cursor position.

Insert tags with completion of contextually valid tags with \\[sgml-insert-tag].
End the current element with \\[sgml-insert-end-tag].  Insert an element (i.e.
both start and end tag) with \\[sgml-insert-element].  Or tag a region with
\\[sgml-tag-region].

To tag a region with the mouse, use transient mark mode or secondary selection.

Structure editing:
\\[sgml-backward-element]  Moves backwards over the previous element.
\\[sgml-forward-element]  Moves forward over the next element.
\\[sgml-down-element]  Move forward and down one level in the element structure.
\\[sgml-backward-up-element]  Move backward out of this element level.
\\[sgml-beginning-of-element]  Move to after the start tag of the current element.
\\[sgml-end-of-element]  Move to before the end tag of the current element.
\\[sgml-kill-element]  Kill the element following the cursor.

Finding interesting positions
\\[sgml-next-data-field]  Move forward to next point where data is allowed.
\\[sgml-next-trouble-spot]  Move forward to next point where something is
	amiss with the structure.

Folding and unfolding
\\[sgml-fold-element]  Fold the lines comprising the current element, leaving
	the first line visible.
\\[sgml-fold-subelement]  Fold the elements in the content of the current element.
	Leaving the first line of every element visible.
\\[sgml-unfold-line]  Show hidden lines in current line.

User options:

sgml-omittag  Set this to reflect OMITTAG in the SGML declaration.
sgml-shorttag  Set this to reflect SHORTTAG in the SGML declaration.
sgml-namecase-general  Set this to reflect NAMECASE GENERAL in the SGML declaration.
sgml-auto-insert-required-elements  If non-nil, automatically insert required
	elements in the content of an inserted element.
sgml-omittag-transparent  If non-nil, will show legal tags inside elements
	with omitable start tags and legal tags beyond omitable end tags.
sgml-leave-point-after-insert  If non-nil, the point will remain after
	inserted tag(s).
sgml-warn-about-undefined-elements  If non-nil, print a warning when a tag
	for a undefined element is found.
sgml-max-menu-size  Max number of entries in Tags and Entities menus before
 	they are split into several panes.
sgml-always-quote-attributes  If non-nil, quote all attribute values
	inserted after finishing edit attributes.
sgml-minimize-attributes  Determines minimization of attributes inserted by
	edit-attributes.
sgml-normalize-trims  If non-nil, sgml-normalize will trim off white space
	from end of element when adding end tag.
sgml-indent-step  How much to increment indent for every element level.
sgml-indent-data  If non-nil, indent in data/mixed context also.
sgml-set-face     If non-nil, psgml will set the face of parsed markup.
sgml-markup-faces The faces used when the above variable is non-nil.
sgml-public-map  Mapping from public identifiers to file names.
sgml-offer-save  If non-nil, ask about saving modified buffers before
		\\[sgml-validate] is run.

All bindings:
\\{sgml-mode-map}

(fn)" t nil)
             (global-quarter-plane-mode "Toggle Quarter-Plane mode in all buffers.
With prefix ARG, enable Global-Quarter-Plane mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Quarter-Plane mode is enabled in all buffers where
`quarter-plane-mode' would do it.
See `quarter-plane-mode' for more information on Quarter-Plane mode.

(fn &optional ARG)" t nil)
             (quarter-plane-mode "Toggle Quarter-Plane mode on or off.
Interactively, with no prefix argument, toggle the mode.
With universal prefix ARG turn mode on.
With zero or negative ARG turn mode off.

Use point movement commands that act as if the text extended
infinitely down and to the right, inserting spaces as necessary.
Excess whitespace is trimmed when saving or exiting Quarter-Plane mode.

Because it works by inserting spaces, Quarter-Plane mode won't work in
read-only buffers.

\\{quarter-plane-mode-map}

(fn &optional ARG)" t nil)
             (rainbow-mode "Colorize strings that represent colors.
This will fontify with colors the string like \"#aabbcc\" or \"blue\".

If called interactively, enable Rainbow mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (rcirc-menu "Show a list of all your `rcirc' buffers." t nil)
             (register-list "Display a list of registers.
An optional argument TYPE defines a regexp to restrict the
register menu to.  A second optional argument FONTIFICATION
decides if the display preserves original fontification for
values.

The default types are defined in `register-list-default-types',
which see.

The list is displayed in a buffer named `*Register List*' in
`register-list-mode', which see.

(fn &optional TYPE FONTIFY)" t nil)
             (relint-buffer "Scan BUFFER for regexp errors. Return list of diagnostics.
Each element in the returned list has the form

  (MESSAGE EXPR-POS ERROR-POS STRING STRING-IDX SEVERITY),

where MESSAGE is the message string, EXPR-POS the location of the
flawed expression, ERROR-POS the exact position of the error or
nil if unavailable, STRING is nil or a string to which the
message pertains, STRING-IDX is nil or an index into STRING,
and SEVERITY is `error' or `warning'.
The intent is that ERROR-POS is the position in the buffer that
corresponds to STRING at STRING-IDX, if such a location can be
determined.

(fn BUFFER)" nil nil)
             (relint-current-buffer "Scan the current buffer for regexp errors.
The buffer must be in emacs-lisp-mode." t nil)
             (relint-directory "Scan all *.el files in DIR for regexp-related errors.

(fn DIR)" t nil)
             (relint-file "Scan FILE, an elisp file, for regexp-related errors.

(fn FILE)" t nil)
             (rich-minority-mode "Toggle Rich minority mode on or off.
With a prefix argument ARG, enable Rich minority mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{rich-minority-mode-map}

(fn &optional ARG)" t nil)
             (rm--mode-list-as-string-list "Return `minor-mode-list' as a simple list of strings.

(fn)" nil nil)
             (rnc-mode "Major mode to edit Relax-NG Compact files.

(fn)" t nil)
             (scanner-scan-multi-images "Scan multiple images, writing them to FILENAME.
A numerical suffix is added to FILENAME for each scanned image.

(fn FILENAME)" t nil)
             (scanner-scan-image "Scan NSCANS images, and write the result to FILENAME.
Without a prefix argument, scan one image.  With a non-numeric
prefix argument, i.e. ‘\\[universal-argument]
\\[scanner-scan-document]’, scan an image and ask the user for
confirmation to scan another image, etc.  With a numeric prefix
argument, e.g. ‘\\[universal-argument] 3
\\[scanner-scan-document]’, scan that many images (in this case,
3).  A numerical suffix is added to FILENAME for each scanned
image.

If ‘scanner-device-name’ is nil or this device is unavailable,
attempt auto-detection.  If more than one scanning device is
available, ask for a selection interactively.

(fn NSCANS FILENAME)" t nil)
             (scanner-scan-multi-doc "Scan a multi-page document, writing them to FILENAME.

(fn FILENAME)" t nil)
             (scanner-scan-document "Scan NPAGES pages and write the result to FILENAME.
Without a prefix argument, scan one page.  With a non-numeric
prefix argument, i.e. ‘\\[universal-argument]
\\[scanner-scan-document]’, scan a page and ask the user for
confirmation to scan another page, etc.  With a numeric prefix
argument, e.g. ‘\\[universal-argument] 3
\\[scanner-scan-document]’, scan that many pages (in this case,
3).

If ‘scanner-device-name’ is nil or this device is unavailable,
attempt auto-detection.  If more than one scanning device is
available, ask for a selection interactively.

(fn NPAGES FILENAME)" t nil)
             (scanner-select-device "Select a scanning DEVICE.
If a prefix argument is supplied, force auto-detection.
Otherwise, auto-detect only if no devices have been detected
previously.

The selected device will be used for any future scan until a new
selection is made.

(fn DEVICE)" t nil)
             (scanner-set-document-resolution "Set the RESOLUTION for scanning documents.

(fn RESOLUTION)" t nil)
             (scanner-set-image-resolution "Set the RESOLUTION for scanning images.

(fn RESOLUTION)" t nil)
             (scanner-select-outputs "Select OUTPUTS for tesseract.

(fn OUTPUTS)" t nil)
             (scanner-select-languages "Select LANGUAGES for optical character recognition.

(fn LANGUAGES)" t nil)
             (scanner-select-papersize "Select the papersize SIZE for document scanning.

(fn SIZE)" t nil)
             (scroll-restore-mode "Toggle Scroll Restore mode.
With arg, turn Scroll Restore mode on if arg is positive, off
otherwise.

In Scroll Restore mode Emacs attempts to restore the original
position that existed before executing a sequence of scrolling
commands whenever that position becomes visible again.  The
option `scroll-restore-commands' permits to specify the set of
commands that may constitute such a sequence.  In addition you
can

- recenter the window when you scroll back to the original
  position, see the option `scroll-restore-recenter',

- aggressively jump back to the original position before
  executing a command not in `scroll-restore-commands', see
  `scroll-restore-jump-back',

- change the appearance of the cursor in the selected window
  while the original position is off-screen, see the option
  `scroll-restore-handle-cursor',

- change the appearance of the region in the selected window
  while the original position is off-screen, see the option
  `scroll-restore-handle-region'.

(fn &optional ARG)" t nil)
             (sed-mode "Sed editing mode.

(fn)" t nil)
             (shelisp-mode "Enable elisp expressions embedded in ANSI APC (Application
Program Control) escape sequences to be located and executed
while in a shell mode buffer.

If called interactively, enable ShElisp mode if ARG is positive, and
disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it
if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (shen-mode "Major mode for editing Shen code.

(fn)" t nil)
             (inferior-shen "Run an inferior Shen process, input and output via buffer `*inferior-shen*'.
If there is a process already running in `*inferior-shen*', just switch
to that buffer.
With argument, allows you to edit the command line (default is value
of `inferior-shen-program').  Runs the hooks from
`inferior-shen-mode-hook' (after the `comint-mode-hook' is run).
(Type \\[describe-mode] in the process buffer for a list of commands.)

(fn CMD)" t nil)
             (sisu-mode "Major mode for editing SiSU files.
SiSU document structuring, publishing in multiple formats and search.
URL `http://www.sisudoc.org/'

(fn)" t nil)
             (sm-c-mode "C editing mode based on SMIE.

(fn)" t nil)
             (smalltalk-mode "Major mode for editing Smalltalk code.

Commands:
\\{smalltalk-mode-map}

(fn)" t nil)
             (gst "Invoke GNU Smalltalk.

(fn COMMAND-LINE)" t nil)
             (smart-yank-mode "Alter the behavior of yank commands in several ways.

If called interactively, enable Smart-Yank mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

Turning on this mode has the following effects:

 - Makes any command except yank commands reset the
  `kill-ring-yank-pointer', instead of only killing commands.

 - Remaps `yank-pop' to `smart-yank-yank-pop'.

 - When yanking an older element from the `kill-ring' with
   \\[smart-yank-yank-pop] (and not replacing it with a subsequent \\[smart-yank-yank-pop]), the
   element is automatically \"moved to the first position\" of
   the `kill-ring' so that `yank' invoked later will again yank
   this element.

(fn &optional ARG)" t nil)
             (sml-yacc-mode "Major Mode for editing ML-Yacc files.

(fn)" t nil)
             (sml-lex-mode "Major Mode for editing ML-Lex files.

(fn)" t nil)
             (sml-cm-mode "Major mode for SML/NJ's Compilation Manager configuration files.

(fn)" t nil)
             (sml-mode "Major mode for editing Standard ML code.
This mode runs `sml-mode-hook' just before exiting.
See also (info \"(sml-mode)Top\").

(fn)" t nil)
             (sml-run "Run the program CMD with given arguments ARG.
The command is run in buffer *CMD* using mode `inferior-sml-mode'.
If the buffer already exists and has a running process, then
just go to this buffer.

If a prefix argument is used, the user is also prompted for a HOST
on which to run CMD using `remote-shell-program'.

(Type \\[describe-mode] in the process's buffer for a list of commands.)

(fn CMD ARG &optional HOST)" t nil)
             (sokoban "Sokoban.

Push the blocks onto the target squares.

sokoban-mode keybindings:
   \\<sokoban-mode-map>
\\[sokoban-start-game]	Starts a new game of Sokoban
\\[sokoban-restart-level]	Restarts the current level
\\[sokoban-goto-level]	Jumps to a specified level
\\[fit-frame-to-buffer]	Fit frame to buffer
\\[sokoban-save]	Save current state
\\[sokoban-load]	Restore saved state
\\[sokoban-move-left]	Move one square to the left
\\[sokoban-move-right]	Move one square to the right
\\[sokoban-move-up]	Move one square up
\\[sokoban-move-down]	Move one square down

(fn)" t nil)
             (speed-of-thought-hook-in "Add functions ON and OFF to `speed-of-thought-mode' hooks.
If `speed-of-thought-mode' is already on, call ON.

(fn ON OFF)" nil nil)
             (speed-of-thought-mode "Toggle Speed-Of-Thought mode on or off.
With a prefix argument ARG, enable Speed-Of-Thought mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{speed-of-thought-mode-map}

(fn &optional ARG)" t nil)
             (spinner-start "Start a mode-line spinner of given TYPE-OR-OBJECT.
If TYPE-OR-OBJECT is an object created with `make-spinner',
simply activate it.  This method is designed for minor modes, so
they can use the spinner as part of their lighter by doing:
    \\='(:eval (spinner-print THE-SPINNER))
To stop this spinner, call `spinner-stop' on it.

If TYPE-OR-OBJECT is anything else, a buffer-local spinner is
created with this type, and it is displayed in the
`mode-line-process' of the buffer it was created it.  Both
TYPE-OR-OBJECT and FPS are passed to `make-spinner' (which see).
To stop this spinner, call `spinner-stop' in the same buffer.

Either way, the return value is a function which can be called
anywhere to stop this spinner.  You can also call `spinner-stop'
in the same buffer where the spinner was created.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

DELAY, if given, is the number of seconds to wait until actually
displaying the spinner. It is safe to cancel the spinner before
this time, in which case it won't display at all.

(fn &optional TYPE-OR-OBJECT FPS DELAY)" nil nil)
             (spinner-create "Create a spinner of the given TYPE.
The possible TYPEs are described in `spinner--type-to-frames'.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

If BUFFER-LOCAL is non-nil, the spinner will be automatically
deactivated if the buffer is killed.  If BUFFER-LOCAL is a
buffer, use that instead of current buffer.

When started, in order to function properly, the spinner runs a
timer which periodically calls `force-mode-line-update' in the
curent buffer.  If BUFFER-LOCAL was set at creation time, then
`force-mode-line-update' is called in that buffer instead.  When
the spinner is stopped, the timer is deactivated.

DELAY, if given, is the number of seconds to wait after starting
the spinner before actually displaying it. It is safe to cancel
the spinner before this time, in which case it won't display at
all.

(fn &optional TYPE BUFFER-LOCAL FPS DELAY)" nil nil)
             (sqlind-setup-style-default "Define an sql-indentation style where keywords are right aligned.

(fn)" t nil)
             (sqlind-setup-style-right "Define an sql-indentation style where keywords are right aligned.

(fn)" t nil)
             (sqlind-setup-style-left "Define an sql-indentation style where keywords are left aligned.

(fn)" t nil)
             (sqlind-setup "Enable SQL syntactic indentation unconditionally.
This function is deprecated, consider using the function
`sqlind-minor-mode' instead." nil nil)
             (sqlind-minor-mode "Toggle SQL syntactic indentation on or off.
With syntactic indentation, hitting TAB on a line in a SQL buffer
will indent the line according to the syntactic context of the
SQL statement being edited.

If called interactively, enable Sqlind minor mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

A set of alignment rules are also enabled with this minor mode.
Selecting a region of text and typing `M-x align RET` will align
the statements.  This can be used, for example, to align the 'as'
column aliases in select statements.

(fn &optional ARG)" t nil)
             (svg-clock "Start/stop the svg clock.

(fn &key SIZE FOREGROUND BACKGROUND NO-SECONDS NO-FACE)" t nil)
             (svg-clock-insert "Insert a self-updating image displaying an analog clock at point.
Optional argument SIZE the size of the clock in pixels.
Optional argument FOREGROUND the foreground color.
Optional argument BACKGROUND the background color.
Optional argument OFFSET the offset in seconds between current and displayed
time.
Optional argument NO-SECONDS says whether to do a seconds hand.
Optional argument NO-FACE says whether to decorate the face.

(fn &optional SIZE FOREGROUND BACKGROUND OFFSET NO-SECONDS NO-FACE)" nil nil)
             (tNFA-regexp-match "Return non-nil if STRING matches REGEXP, nil otherwise.
Sets the match data if there was a match; see `match-beginning',
`match-end' and `match-string'.

REGEXP and STRING can be any sequence type (vector, list, or
string); they need not be actual strings. Special characters in
REGEXP are still just that: elements of the sequence that are
characters which have a special meaning in regexps.

The :test keyword argument specifies how to test whether two
individual elements of STRING are identical. The default is `eq'.

Only a subset of the full Emacs regular expression syntax is
supported. There is no support for regexp constructs that are
only meaningful for strings (character ranges and character
classes inside character alternatives, and syntax-related
backslash constructs). Back-references and non-greedy postfix
operators are not supported, so `?' after a postfix operator
loses its special meaning. Also, matches are always anchored, so
`$' and `^' lose their special meanings (use `.*' at the
beginning and end of the regexp to get an unanchored match).

(fn REGEXP STRING &key (test (quote eq)))" nil nil)
             (tNFA-from-regexp "Create a tagged NFA that recognizes the regular expression REGEXP.
The return value is the initial state of the tagged NFA.

REGEXP can be any sequence type (vector, list, or string); it
need not be an actual string. Special characters in REGEXP are
still just that: elements of the sequence that are characters
which have a special meaning in regexps.

The :test keyword argument specifies how to test whether two
individual elements of STRING are identical. The default is `eq'.

Only a subset of the full Emacs regular expression syntax is
supported. There is no support for regexp constructs that are
only meaningful for strings (character ranges and character
classes inside character alternatives, and syntax-related
backslash constructs). Back-references and non-greedy postfix
operators are not supported, so `?' after a postfix operator
loses its special meaning. Also, matches are always anchored, so
`$' and `^' lose their special meanings (use `.*' at the
beginning and end of the regexp to get an unanchored match).

(fn REGEXP &key (test (quote eq)))" nil nil)
             (temp-buffer-browse-mode "Toggle Temp-Buffer-Browse mode on or off.
With a prefix argument ARG, enable Temp-Buffer-Browse mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.
\\{temp-buffer-browse-mode-map}

(fn &optional ARG)" t nil)
             (temp-buffer-browse-activate "Activate temporary key bindings for current window.
Specifically set up keys `SPC', `DEL' and `RET' to scroll up,
scroll down and close the temp buffer window, respectively.

(fn)" nil nil)
             (test-simple-run "Register command line to run tests non-interactively and bind key to run test.
After calling this function, you can run test by key specified by `test-simple-runner-key'.

It is preferable to write at the first line of test files as a comment, e.g,
;;;; (test-simple-run \"emacs -batch -L %s -l %s\" (file-name-directory (locate-library \"test-simple.elc\")) buffer-file-name)

Calling this function interactively, COMMAND-LINE-FORMATS is set above.

(fn &rest COMMAND-LINE-FORMATS)" t nil)
             (test-simple-clear "Initialize and reset everything to run tests.
You should run this before running any assertions.  Running more than once
clears out information from the previous run.

(fn &optional TEST-INFO TEST-START-MSG)" t nil)
             (test-simple-start "

(fn &optional TEST-START-MSG)" nil t)
             (tf-with-timeout "Like `with-timeout' but with support for unbreakable code.

Provides ability to inhibit timeout during parts of the body.
Note that most of the time, you may not need this functionality
at all unless you want to be very “clean” about things---you
could get by with the regular with-timeout and not using
sit-for's in the body.  Or with the regular with-timeout and
using unwind-protect.


A judicious use of `unwind-protect' may seem to alleviate the
need for this function. This function, however, provides
additional flexibility in that the inhibitedness can be altered
at run-time depending on various conditions.


Run BODY, but if it doesn't finish in SECONDS seconds, give up.
If we give up, we run the TIMEOUT-FORMS which are contained in TLIST
and return the value of the last one.
The call should look like:
 (tf-with-timeout quoted-expr (SECONDS TIMEOUT-FORMS...) BODY...)

The timeout is checked whenever Emacs waits for some kind of external
event (such as keyboard input, input from subprocesses, or a certain time);
if the program loops without waiting in any way, the timeout will not
be detected.  Furthermore:

During the execution of the body, we SHALL NOT time out when INHIBIT-VAR's
content is non-nil.  Thus, for example, you might initially setq a
variable my-var as nil, supply inhibitp as `my-var', and then you may
setq my-var to t or nil within the body of tf-with-timeout to enable
or disable timeout.  The best use of this functionality is to setq
inhibitp to t when during parts of loops where you do not want the
body broken within certain parts of the loop.  (Of course, if that
part of the loop does not contain any sit-for's or read's then you
don't have to worry about this in the first place..)


Again, Do not forget to bind my-var to some value before attempting to use this
tf-with-timeout :)

Here's an example:


 (let ((myinhibit t))
  (tf-with-timeout \\='myinhibit \\='mytag \\='mytimedoutvar
		   (2 2)
		   (setq a nil)
		   (setq b nil)
		   (sit-for 4)
		   (setq a 4)
		   (setq myinhibit nil)
		   (sit-for 2)
		   (setq b 5)
		   ))


The above example requests a timeout within 2 seconds.  However, the
timeout can takes place only when myinhibit is set to nil,
which becomes true after about 4 seconds.  Thus, after the execution of the
body, a has the value 4, but b has the value nil.

See `tf-test-timeout' for another example.

Important Note: If the body of a loop tends to stay in a timeout
inhibited region for most of the time, then make sure that the timeout
enabled region atleast spans about 0.02 seconds.. thus, use (sleep-for
0.02) if needed.. this is because we check every 0.01 seconds if an
uninhibited timeout condition has been satisfied.

But perhaps you do not want to include (sleep-for 0.02) because that
wastes precious cpu time.  Simple, don't include it, just after a long
inhibited body, you can include a timeout check within the body
instead of (sleep-for 0.02):
 (tf-with-timeout-check \\='mytag \\='mytimedoutvar \\='myinhibitp)

Moreover, if that is the main check you rely on, you it perhaps makes
sense to increase the value of `tf-with-timeout-repeat-sec', so that
your cpu cycles are not wasted every 0.01 sec.  See the doc of that
variable for more.

TIMERTAG should be a quoted symbol, also we WILL set that symbol to t
during the execution of these forms.

TIMEDOUTVAR is the variable that times out.

(fn INHIBIT-VAR TIMERTAG TIMEDOUTVAR TLIST &rest BODY)" nil t)
             (tf-run-with-idle-timer "Similar to `run-with-idle-timer', except that provides more options.

Args are SECS, REPEAT, REDOSECS, REDOREPEAT, INCLUDERUNTIME,
FUNCTION and &rest ARGS.

Similar to `run-with-idle-timer', but provides more options.
Suppose you want Emacs to run an action every REDOSECS for as
long as Emacs remains idle.  Emacs' `run-with-idle-timer' will
perform the action exactly once every time Emacs goes idle.  This
function, on the other hand, will allow
you to keep performing an action as long as Emacs remains idle.

SECS is the number of seconds to wait once Emacs has first gone
idle or a function that returns this number when called with no arguments.
Note that the way `run-with-idle-timer' is defined, SECS will
unfortunately be called immediately after you call this function, but
REDOSECS will be *every* time Emacs *remains* idle..yay..

If REDOREPEAT is non-nil, the action is repeated as long Emacs remains
idle.  REDOSECS is the number of additional seconds (after the action
has been done) to wait if Emacs remains idle before performing the
action again.  Again, redosecs does not have to be a number, it can be
a function which yields such a number...

If INCLUDERUNTIME is non-nil, REDOSECS is the number of
additional seconds to wait after the action has been invoked (not
finished).

If REPEAT is nonnil, the entire cycle is repeated every time Emacs
next goes idle.. (as in the default `run-with-idle-timer').

(fn SECS REPEAT REDOSECS REDOREPEAT INCLUDERUNTIME FUNCTION &rest ARGS)" nil nil)
             (tf-time-difference "Return the time in seconds elaspsed from TIMESUB to TIMEPLUS.

Conceptually:  (- TIMEPLUS TIMESUB ).

(fn TIMEPLUS TIMESUB)" nil nil)
             (timerfunctions-introduction "Provides electric help from variable `timerfunctions-introduction'." t nil)
             (tiny-helper "Helper function for `tiny-expand'.

The arguments to this function construct a “tiny expression”
\"mBSEO|F\" where
  E is the end value (END-VAL)     - defaults to 0 internally if nil or \"\",
                                      or 9 if BEGIN-VAL is nil or \"\" too.
  B is the begin value (BEGIN-VAL) - defaults to 0 internally if nil or \"\".
  S is the separator (SEP)         - defaults to \" \" if nil or \"\".
  O is the elisp operation (OP)    - defaults to \"\" if nil.
  F is the format (FMT)            - defaults to \"\" if nil.

If `tiny' expansion is possible at point, do it.
Otherwise activate the helper to generate a valid “tiny
expression” and expand that.

Usage: Call TINY-HELPER, ↵↵↵↵↵            -> 0 1 2 3 4 5 6 7 8 9
       Call TINY-HELPER, 9↵2↵_↵+1*x2↵↵    -> 5_7_9_11_13_15_17_19
       Call TINY-HELPER, 15↵1↵↵-30*2x↵%x↵ -> 1c 1a 18 16 14 12 10 e c a 8 6 4 2 0

(fn &optional END-VAL BEGIN-VAL SEP OP FMT)" t nil)
             (tiny-expand "Expand current snippet.
It polls the expander functions one by one
if they can expand the thing at point.
First one to return a string succeeds.
These functions are expected to set `tiny-beg' and `tiny-end'
to the bounds of the snippet that they matched.
At the moment, only `tiny-mapconcat' is supported.
`tiny-mapconcat2' should be added to expand rectangles.

(fn)" t nil)
             (transcribe-mode "Toggle transcribe-mode

(fn &optional ARG)" t nil)
             (define-infix-command "Define NAME as a transient infix command.

ARGLIST is always ignored and reserved for future use.
DOCSTRING is the documentation string and is optional.

The key-value pairs are mandatory.  All transient infix commands
are equal to each other (but not eq), so it is meaningless to
define an infix command without also setting at least `:class'
and one other keyword (which it is depends on the used class,
usually `:argument' or `:variable').

Each key has to be a keyword symbol, either `:class' or a keyword
argument supported by the constructor of that class.  The
`transient-switch' class is used if the class is not specified
explicitly.

The function definitions is always:

   (lambda ()
     (interactive)
     (let ((obj (transient-suffix-object)))
       (transient-infix-set obj (transient-infix-read obj)))
     (transient--show))

`transient-infix-read' and `transient-infix-set' are generic
functions.  Different infix commands behave differently because
the concrete methods are different for different infix command
classes.  In rare case the above command function might not be
suitable, even if you define your own infix command class.  In
that case you have to use `transient-suffix-command' to define
the infix command and use t as the value of the `:transient'
keyword.

(fn NAME ARGLIST [DOCSTRING] [KEYWORD VALUE]...)" nil t)
             (define-suffix-command "Define NAME as a transient suffix command.

ARGLIST are the arguments that the command takes.
DOCSTRING is the documentation string and is optional.

These arguments can optionally be followed by key-value pairs.
Each key has to be a keyword symbol, either `:class' or a
keyword argument supported by the constructor of that class.
The `transient-suffix' class is used if the class is not
specified explicitly.

The BODY must begin with an `interactive' form that matches
ARGLIST.  The infix arguments are usually accessed by using
`transient-args' inside `interactive'.

(fn NAME ARGLIST [DOCSTRING] [KEYWORD VALUE]... BODY...)" nil t)
             (define-transient-command "Define NAME as a transient prefix command.

ARGLIST are the arguments that command takes.
DOCSTRING is the documentation string and is optional.

These arguments can optionally be followed by key-value pairs.
Each key has to be a keyword symbol, either `:class' or a keyword
argument supported by the constructor of that class.  The
`transient-prefix' class is used if the class is not specified
explicitly.

GROUPs add key bindings for infix and suffix commands and specify
how these bindings are presented in the popup buffer.  At least
one GROUP has to be specified.  See info node `(transient)Binding
Suffix and Infix Commands'.

The BODY is optional.  If it is omitted, then ARGLIST is also
ignored and the function definition becomes:

  (lambda ()
    (interactive)
    (transient-setup \\='NAME))

If BODY is specified, then it must begin with an `interactive'
form that matches ARGLIST, and it must call `transient-setup'.
It may however call that function only when some condition is
satisfied; that is one of the reason why you might want to use
an explicit BODY.

All transients have a (possibly nil) value, which is exported
when suffix commands are called, so that they can consume that
value.  For some transients it might be necessary to have a sort
of secondary value, called a scope.  Such a scope would usually
be set in the commands `interactive' form and has to be passed
to the setup function:

  (transient-setup \\='NAME nil nil :scope SCOPE)

(fn NAME ARGLIST [DOCSTRING] [KEYWORD VALUE]... GROUP... [BODY...])" nil t)
             (global-undo-tree-mode "Toggle Undo-Tree mode in all buffers.
With prefix ARG, enable Global Undo-Tree mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Undo-Tree mode is enabled in all buffers where
`turn-on-undo-tree-mode' would do it.
See `undo-tree-mode' for more information on Undo-Tree mode.

(fn &optional ARG)" t nil)
             (undo-tree-mode "Toggle undo-tree mode.
With no argument, this command toggles the mode.
A positive prefix argument turns the mode on.
A negative prefix argument turns it off.

If called interactively, enable Undo-Tree mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

Undo-tree-mode replaces Emacs' standard undo feature with a more
powerful yet easier to use version, that treats the undo history
as what it is: a tree.

The following keys are available in `undo-tree-mode':

  \\{undo-tree-map}

Within the undo-tree visualizer, the following keys are available:

  \\{undo-tree-visualizer-mode-map}

(fn &optional ARG)" t nil)
             (uniq-file-read "For `project-read-file-name-function'.

(fn PROMPT ALL-FILES &optional PREDICATE HIST DEFAULT)" nil nil)
             (url-ntlm-auth "Return an NTLM HTTP authorization header.
Get the contents of the Authorization header for a HTTP response
using NTLM authentication, to access URL.  Because NTLM is a
two-step process, this function expects to be called twice, first
to generate the NTLM type 1 message (request), then to respond to
the server's type 2 message (challenge) with a suitable response.

url-get-authentication' calls `url-ntlm-auth' once when checking
what authentication schemes are supported (PROMPT and ARGS are
nil), and then twice for every stage of the handshake: the first
time PROMPT is nil, the second, t; ARGS contains the server
response's \"WWW-Authenticate\" header, munged by
`url-parse-args'.

If PROMPT is not t then this function just returns nil.  This is
to avoid calculating responses twice.

OVERWRITE and REALM are ignored.

ARGS is expected to contain the WWW-Authentication header from
the server's last response.  These are used by
`url-http-get-stage' to determine what stage we are at.

(fn URL &optional PROMPT OVERWRITE REALM ARGS)" nil nil)
             (validate-mark-safe-local "Mark SYMBOL as a safe local if its custom type is obeyed.

(fn SYMBOL)" nil nil)
             (validate-variable "Check that SYMBOL's value matches its schema.
SYMBOL must be the name of a custom option with a defined
`custom-type'. If SYMBOL has a value and a type, they are checked
with `validate-value'. NOERROR is passed to `validate-value'.

(fn SYMBOL &optional NOERROR)" nil nil)
             (validate-value "Check that VALUE matches SCHEMA.
If it matches return VALUE, otherwise signal a `user-error'.

If NOERROR is non-nil, return t to indicate a match and nil to
indicate a failure.

(fn VALUE SCHEMA &optional NOERROR)" nil nil)
             (vcard-parse-buffer "Parse current buffer, containing vCard data.
Returns a list of contact objects." t nil)
             (vcard-parse-file "Parse FILE containing vCard data into an alist.

(fn FILE)" t nil)
             (vcard-mode "Major mode for viewing vCard files.

(fn)" t nil)
             (vcl-mode "Major mode for editing Varnish Configuration Language code.

Key bindings:
\\{vcl-mode-map}

(fn)" t nil)
             (vdiff-current-file "Start vdiff between current buffer and its file on disk.
This command can be used instead of `revert-buffer'.  If there is
nothing to revert then this command fails.

(fn)" t nil)
             (vdiff-files3 "Start a vdiff session with 3 files. If called interactively,
you will be asked to select two files.

(fn FILE-A FILE-B FILE-C &optional ON-QUIT)" t nil)
             (vdiff-merge-conflict "Start vdiff session using merge conflicts marked in FILE.

(fn FILE &optional RESTORE-WINDOWS-ON-QUIT)" t nil)
             (vdiff-buffers3 "Start a vdiff session. If called interactively, you will be
asked to select two buffers. ON-QUIT is a function to run on
exiting the vdiff session. It is called with the three vdiff
buffers as arguments. The last two options, RESTORE-WINDOWS-ON-QUIT and
KILL-BUFFERS-ON-QUIT restore the previous window configuration
and kill the vdiff buffers after quitting vdiff. Note that if you
are going to kill the buffers you should probably be using a
function for ON-QUIT to do something useful with the result.

(fn BUFFER-A BUFFER-B BUFFER-C &optional ON-QUIT RESTORE-WINDOWS-ON-QUIT KILL-BUFFERS-ON-QUIT)" t nil)
             (vdiff-buffers "Start a vdiff session. If called interactively, you will be
asked to select two buffers. ROTATE adjusts the buffer's
initial layout. A prefix argument can be used to set this
variable interactively. ON-QUIT is a function to run on exiting
the vdiff session. It is called with the two vdiff buffers as
arguments. The last two options, RESTORE-WINDOWS-ON-QUIT and
KILL-BUFFERS-ON-QUIT restore the previous window configuration
and kill the vdiff buffers after quitting vdiff. Note that if you
are going to kill the buffers you should probably be using a
function for ON-QUIT to do something useful with the result.

(fn BUFFER-A BUFFER-B &optional ROTATE ON-QUIT RESTORE-WINDOWS-ON-QUIT KILL-BUFFERS-ON-QUIT)" t nil)
             (vdiff-files "Start a vdiff session. If called interactively, you will be
asked to select two files. ROTATE adjusts the buffer's
initial layout. A prefix argument can be used to set this
variable interactively. ON-QUIT is a function to run on exiting
the vdiff session. It is called with the two vdiff buffers as
arguments.

(fn FILE-A FILE-B &optional ROTATE ON-QUIT)" t nil)
             (vigenere-encrypt-buffer "Encrypt the current buffer with a Vigenere cipher using KEY.

Note: A Vigenere cipher should not be considered
cryptographically secure.

(fn KEY)" t nil)
             (vigenere-decrypt-buffer "Decrypt the current buffer with a Vigenere cipher using KEY.

Note: A Vigenere cipher should not be considered
cryptographically secure.

(fn KEY)" t nil)
             (vigenere-encrypt-region "Encrypt region from BEGIN to END with a Vigenere cipher using KEY.

Note: A Vigenere cipher should not be considered
cryptographically secure.

(fn KEY BEGIN END)" t nil)
             (vigenere-decrypt-region "Decrypt region from BEGIN to END with a Vigenere cipher using KEY.

Note: A Vigenere cipher should not be considered
cryptographically secure.

(fn KEY BEGIN END)" t nil)
             (visual-fill-mode "Auto-refill paragraphs without modifying the buffer.

If called interactively, enable Visual-Fill mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (vlf-occur-load "Load serialized `vlf-occur' results from current buffer.

(fn)" t nil)
             (vlf-ediff-files "Run batch by batch ediff over FILE-A and FILE-B.
Files are processed with VLF with BATCH-SIZE chunks.
Requesting next or previous difference at the end or beginning
respectively of difference list, runs ediff over the adjacent chunks.

(fn FILE-A FILE-B BATCH-SIZE)" t nil)
             (vlf "View Large FILE in batches.  When MINIMAL load just a few bytes.
You can customize number of bytes displayed by customizing
`vlf-batch-size'.
Return newly created buffer.

(fn FILE &optional MINIMAL)" t nil)
             (wcheck-actions "Offer actions for marked text.

This function is usually called through a right mouse button
event or interactively by a user. In both cases function's
arguments are filled automatically.

If buffer position POS is on marked text (and action program is
properly configured) show a menu of actions. When this function
is called interactively POS is automatically the current point
position. Optional EVENT argument is a mouse event which is
present if this function is called through a right mouse button
click on marked text. If EVENT is non-nil use a graphic toolkit's
menu (when available) for selecting actions. Otherwise use a text
menu.

When user chooses one of the options from the menu the related
action is executed. It could mean that the original marked text
is replaced with the chosen substitute. Menu options can trigger
any kind of actions, though.

(fn POS &optional EVENT)" t nil)
             (wcheck-jump-backward "Move point backward to previous marked text area." t nil)
             (wcheck-jump-forward "Move point forward to next marked text area." t nil)
             (wcheck-mode "General interface for text checkers.

With optional (prefix) ARG turn on the mode if ARG is positive,
otherwise turn it off. If ARG is not given toggle the mode.

Wcheck is a minor mode for automatically checking and marking
strings in Emacs buffer. Wcheck sends (parts of) buffer's content
to a text-checker back-end and, relying on its output, decides if
some parts of text should be marked.

Wcheck can be used with external spell-checker programs such as
Ispell and Enchant, but actually any tool that can receive text
stream from standard input and send text to standard output can
be used. The checker back-end can also be an Emacs Lisp function.

Different configuration units are called \"languages\". See the
documentation of variables `wcheck-language-data',
`wcheck-language-data-defaults' and `wcheck-language' for
information on how to configure Wcheck mode. You can access and
configure the variables through customize group `wcheck'.

Interactive command `wcheck-change-language' is used to switch
languages. Command `wcheck-actions' gives an action menu for the
marked text at point (also accessible through the right-click
mouse menu). Commands `wcheck-jump-forward' and
`wcheck-jump-backward' move point to next/previous marked text
area.

A note for Emacs Lisp programmers: Emacs Lisp function
`wcheck-marked-text-at' returns information about marked text at
a buffer position. Function `wcheck-query-language-data' can be
used for querying effective configuration data for any language.

(fn &optional ARG)" t nil)
             (wcheck-change-language "Change language for current buffer (or globally).
Change `wcheck-mode' language to LANGUAGE. The change is
buffer-local but if GLOBAL is non-nil (prefix argument if called
interactively) then change the global default language.

(fn LANGUAGE &optional GLOBAL)" t nil)
             (wconf-create "Clone the current configuration or create a new \"empty\" one.
The new configuration is appended to the list and becomes active.

With optional prefix argument NEW, or if there are no
configurations yet, create a new configuration from the current
window config.

(fn &optional NEW)" t nil)
             (wconf-load "Load stored configurations from FILENAME, defaults to
`wconf-file'.

(fn &optional FILENAME)" t nil)
             (ws-start "Start a server using HANDLERS and return the server object.

HANDLERS may be a single function (which is then called on every
request) or a list of conses of the form (MATCHER . FUNCTION),
where the FUNCTION associated with the first successful MATCHER
is called.  Handler functions are called with two arguments, the
process and the request object.

A MATCHER may be either a function (in which case it is called on
the request object) or a cons cell of the form (KEYWORD . STRING)
in which case STRING is matched against the value of the header
specified by KEYWORD.

Any supplied NETWORK-ARGS are assumed to be keyword arguments for
`make-network-process' to which they are passed directly.

For example, the following starts a simple hello-world server on
port 8080.

  (ws-start
   (lambda (request)
     (with-slots (process headers) request
       (process-send-string process
        \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\nhello world\")))
   8080)

Equivalently, the following starts an identical server using a
function MATCH and the `ws-response-header' convenience
function.

  (ws-start
   \\='(((lambda (_) t) .
      (lambda (proc request)
        (ws-response-header proc 200 \\='(\"Content-type\" . \"text/plain\"))
        (process-send-string proc \"hello world\")
        t)))
   8080)

(fn HANDLERS PORT &optional LOG-BUFFER &rest NETWORK-ARGS)" nil nil)
             (webfeeder-build "Build a WEBFEED out of HTML-FILES.
The WEBFEED is an XML file that contains every blog post in a
machine-readable format.

The WEBFEED file is stored in PROJECT-DIR where HTML-FILES are
also assumed to reside.

For more details on the other arguments, see
`webfeeder-make-atom', `webfeeder-make-rss' and
`webfeeder-html-files-to-items'.

(fn WEBFEED PROJECT-DIR URL HTML-FILES &key TITLE SUBTITLE DESCRIPTION AUTHOR GENERATOR BUILD-DATE PREDICATE MAX-ENTRIES (BUILDER \\='webfeeder-make-atom))" nil nil)
             (webfeeder-make-atom "Return a webfeed string in Atom format that contains every FEED-ITEMS.

WEBFEED is the path where the feed is intended to be stored,
relative to URL.

A feed can have a TITLE: if not, the URL will be used.

When BUILD-DATE is nil, use `current-time'.  Otherwise it can be
a time expression as in `current-time'.  0 means EPOCH.

When provided, FEED-ITEMS are only added if (PREDICATE FEED-ITEM)
returns non-nil.

The number of items is limited to MAX-ENTRIES.  When nil, all
items are included.

FEED-ITEMS can be generated with `webfeeder-html-files-to-items'.

(fn WEBFEED URL FEED-ITEMS &key TITLE SUBTITLE AUTHOR GENERATOR BUILD-DATE PREDICATE MAX-ENTRIES &allow-other-keys)" nil nil)
             (webfeeder-make-rss "Return a webfeed string in RSS format that contains every FEED-ITEMS.

WEBFEED is the path where the feed is intended to be stored,
relative to URL.

A feed can have a TITLE and DESCRIPTION: if not, the URL will be
used.

When BUILD-DATE is nil, use `current-time'.  Otherwise it can be
a time expression as in `current-time'.  0 means EPOCH.

When provided, FEED-ITEMS are only added if (PREDICATE FEED-ITEM)
returns non-nil.

The number of items is limited to MAX-ENTRIES.  When nil, all
items are included.

FEED-ITEMS can be generated with `webfeeder-html-files-to-items'.

(fn WEBFEED URL FEED-ITEMS &key TITLE DESCRIPTION AUTHOR GENERATOR BUILD-DATE PREDICATE MAX-ENTRIES &allow-other-keys)" nil nil)
             (webfeeder-html-files-to-items "Parse the source HTML-FILES and return a list of webfeeder-items.
PROJECT-DIR is where HTML files are also assumed to reside.
PROJECT-DIR is the local root of the website hosted at URL.
HTML parsing details can be customized through the following
variables:
- `webfeeder-author-function'
- `webfeeder-date-function'
- `webfeeder-title-function'
- `webfeeder-subtitle-function'
- `webfeeder-body-function'.
- `webfeeder-categories-function'.
- `webfeeder-generator-function'.

(fn PROJECT-DIR URL HTML-FILES)" nil nil)
             (windresize "Resize windows interactively.
INCREMENT is the number of lines by which borders should move.

By default, the method for resizing is by moving the borders.
The left/right key will move the only movable vertical border to
the left/right and the up/down key will move the only horizontal
movable border up/down.  If there are two movable borders, the
right and the bottom border will have priority over the left and
upper border.  You can reverse this priority by using \\[windresize-left-force-left],
\\[windresize-right-force-left], etc.

Resizing can also be done by increasing/decreasing the window
width and height.  The up and down arrow keys will enlarge or
shrink the window vertically and the right and left arrow keys
will enlarge or shrink the window horizontally.

You can toggle the method with \\[windresize-toggle-method].

You can set the number of line by which a border should move by
calling \\[windresize-set-increment] with a numeric prefix.
You can temporarily negate the number of lines by which the
windows are resized by using \\[windresize-left-minus], \\[windresize-right-minus], etc.
If you want to permanently negate this increment value,
use `\\[windresize-negate-increment]' instead.

You can also save window configurations with `\\[windresize-save-window-configuration]' in a ring,
and restore them with `\\[windresize-restore-window-configuration]'.

`\\[windresize-cancel-and-quit]' will quit `windresize' and cancel any change.  `\\[windresize-exit]'
will set the new window configuration and exit.

\\{windresize-map}

(fn &optional INCREMENT)" t nil)
             (wisitoken-grammar-mode "A major mode for Wisi grammar files.

(fn)" t nil)
             (100secwp "Start game.

(fn)" t nil)
             (xclip-mode "Minor mode to use the `xclip' program to copy&paste.

If called interactively, enable Xclip mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

(fn &optional ARG)" t nil)
             (xpm-m2z-circle "Like `xpm-m2z-ellipse' with a shared radius RADIUS.

(fn CX CY RADIUS)" nil nil)
             (xpm-m2z-ellipse "Return an ellipse with center (CX,CY) and radii RX and RY.
Both CX and CY must be non-integer, preferably
precisely half-way between integers, e.g., 13/2 => 6.5.
The ellipse is represented as a list of unique XPM coords,
with the \"span\", i.e., (- HI LO -1), of the extreme X and Y
components equal to twice the rounded (to integer) value of
RX and RY, respectively.  For example:

 (xpm-m2z-ellipse 1.5 3.5 5.8 4.2)
 => list of length 20

    min  max  span
 X   -3    6    10
 Y    0    7     8

The span is always an even number.  As a special case, if the
absolute value of RX or RY is less than 1, the value is nil.

(fn CX CY RX RY)" nil nil)
             (xpm-generate-buffer "Return a new buffer in XPM image format.
In this buffer, undo is disabled (see `buffer-enable-undo').

NAME is the buffer and XPM name.  For best interoperation
with other programs, NAME should be a valid C identifier.
WIDTH, HEIGHT and CPP are integers that specify the image
width, height and characters/pixel, respectively.

PALETTE is an alist ((PX . COLOR) ...), where PX is either
a character or string of length CPP, and COLOR is a string.
If COLOR includes a space, it is included directly,
otherwise it is automatically prefixed with \"c \".

For example, to produce palette fragment:

 \"X  c blue\",
 \"Y  s border c green\",

you can specify PALETTE as:

 ((?X . \"blue\")
  (?Y . \"s border c green\"))

This example presumes CPP is 1.

(fn NAME WIDTH HEIGHT CPP PALETTE)" nil nil)
             (xpm-grok "Analyze buffer and prepare internal data structures.
When called as a command, display in the echo area a
summary of image dimensions, cpp and palette.
Set buffer-local variable `xpm--gg' and return its value.
Normally, preparation includes making certain parts of the
buffer intangible.  Optional arg SIMPLE non-nil inhibits that.

(fn &optional SIMPLE)" t nil)
             (xr-skip-set-pp "Convert a skip set string to `rx' notation and pretty-print.
This function uses `xr-skip-set' to translate SKIP-SET-STRING
into DIALECT.
It is intended for use from an interactive elisp session.
See `xr' for a description of the DIALECT argument.

(fn SKIP-SET-STRING &optional DIALECT)" nil nil)
             (xr-pp "Convert to `rx' notation and output the pretty-printed result.
This function uses `xr' to translate RE-STRING into DIALECT.
It is intended for use from an interactive elisp session.
See `xr' for a description of the DIALECT argument.

(fn RE-STRING &optional DIALECT)" nil nil)
             (xr-skip-set-lint "Detect dubious practices and possible mistakes in SKIP-SET-STRING.
This includes uses of tolerated but discouraged constructs.
Outright syntax violations are signalled as errors.
The argument is interpreted according to the syntax of
`skip-chars-forward' and `skip-chars-backward'.
Return a list of (OFFSET . COMMENT) where COMMENT applies at OFFSET
in SKIP-SET-STRING.

(fn SKIP-SET-STRING)" nil nil)
             (xr-lint "Detect dubious practices and possible mistakes in RE-STRING.
This includes uses of tolerated but discouraged constructs.
Outright regexp syntax violations are signalled as errors.
If PURPOSE is `file', perform additional checks assuming that RE-STRING
is used to match a file name.
Return a list of (OFFSET . COMMENT) where COMMENT applies at OFFSET
in RE-STRING.

(fn RE-STRING &optional PURPOSE)" nil nil)
             (xr-skip-set "Convert a skip set string argument to rx notation.
SKIP-SET-STRING is interpreted according to the syntax of
`skip-chars-forward' and `skip-chars-backward' and converted to
a character class on `rx' form.
If desired, `rx' can then be used to convert the result to an
ordinary regexp.
See `xr' for a description of the DIALECT argument.

(fn SKIP-SET-STRING &optional DIALECT)" nil nil)
             (xr "Convert a regexp string to rx notation; the inverse of `rx'.
Passing the returned value to `rx' (or `rx-to-string') yields a regexp string
equivalent to RE-STRING.  DIALECT controls the choice of keywords,
and is one of:
`verbose'       -- verbose keywords
`brief'         -- short keywords
`terse'         -- very short keywords
`medium' or nil -- a compromise (the default)

(fn RE-STRING &optional DIALECT)" nil nil)
             (snippet-mode "A mode for editing yasnippets" t nil)
             (yas-global-mode "Toggle Yas minor mode in all buffers.
With prefix ARG, enable Yas-Global mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Yas minor mode is enabled in all buffers where
`yas-minor-mode-on' would do it.
See `yas-minor-mode' for more information on Yas minor mode.

(fn &optional ARG)" t nil)
             (yas-minor-mode "Toggle YASnippet mode.

If called interactively, enable Yas minor mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

When YASnippet mode is enabled, `yas-expand', normally bound to
the TAB key, expands snippets of code depending on the major
mode.

With no argument, this command toggles the mode.
positive prefix argument turns on the mode.
Negative prefix argument turns off the mode.

Key bindings:
\\{yas-minor-mode-map}

(fn &optional ARG)" t nil)
             (ztree-mode "A major mode for displaying the directory tree in text mode.

(fn)" t nil)
             (ztree-dir "Create an interactive buffer with the directory tree of the PATH given.

(fn PATH)" t nil)
             (ztree-diff "Create an interactive buffer with the directory tree of the path given.
Argument DIR1 left directory.
Argument DIR2 right directory.

(fn DIR1 DIR2)" t nil)
             (ztreediff-mode "A minor mode for displaying the difference of the directory trees in text mode.

(fn &optional ARG)" t nil)
             ))
  (let ((f (car x)))
    (unless (fboundp f)
      (apply #'autoload f "gnu-elpa" (cdr x)))))
(unless (fboundp 'pcomplete/ack-grep) (defalias 'pcomplete/ack-grep 'pcomplete/ack))
(unless (fboundp 'aggressive-indent-global-mode) (defalias 'aggressive-indent-global-mode #'global-aggressive-indent-mode))
(add-to-list 'auto-mode-alist '("\\.trf?\\'" . arbitools-mode))
(add-to-list 'auto-mode-alist '("\\.bnf\\'" . bnf-mode))
(add-to-list 'auto-mode-alist '("\\.pgn\\'" . chess-pgn-mode))
(unless (fboundp 'pgn-mode) (defalias 'pgn-mode 'chess-pgn-mode))
(unless (fboundp 'chess-session) (defalias 'chess-session 'chess))
(add-to-list 'auto-mode-alist '("Cakefile" . coffee-mode))
(add-to-list 'auto-mode-alist '("\\.coffee\\'" . coffee-mode))
(add-to-list 'auto-mode-alist '("\\.tsv\\'" . tsv-mode))
(add-to-list 'auto-mode-alist '("\\.[Cc][Ss][Vv]\\'" . csv-mode))
(unless (fboundp 'dictree-create-custom) (defalias 'dictree-create-custom 'make-dictree-custom))
(unless (fboundp 'dictree-create) (defalias 'dictree-create 'make-dictree))
(add-to-list 'auto-mode-alist '("\\.djvu\\'" . djvu-dummy-mode))
(add-to-list 'auto-mode-alist '("\\.dtsi?\\'" . dts-mode))
(unless (fboundp 'easy-mark-sexp) (defalias 'easy-mark-sexp 'easy-mark "Use `easy-mark' instead. The alias may be removed in future."))
(add-to-list 'auto-mode-alist '("\\.fountain\\'" . fountain-mode))
(unless (fboundp 'gited-list) (defalias 'gited-list 'gited-list-branches))
(add-to-list 'auto-mode-alist '("\\.gle\\'" . gle-mode))
(unless (fboundp 'heap-create) (defalias 'heap-create 'make-heap))
(add-to-list 'auto-mode-alist '("\\.jgr\\'" . jgraph-mode))
(add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode))
(unless (fboundp 'landmark-repeat) (defalias 'landmark-repeat 'landmark-test-run))
(add-to-list 'auto-mode-alist '("\\.elmc\\'" . lmc-asm-mode))
(add-to-list 'auto-mode-alist '("\\.omn\\'" . omn-mode))
(add-to-list 'auto-mode-alist '("\\.pomn\\'" . omn-mode))
(unless (fboundp 'global-on-screen-mode) (defalias 'global-on-screen-mode 'on-screen-global-mode))
(add-to-list 'auto-mode-alist '("\\.rnc\\'" . rnc-mode))
(add-to-list 'interpreter-mode-alist '("sed" . sed-mode))
(add-to-list 'auto-mode-alist '("\\.sed\\'" . sed-mode))
(add-to-list 'auto-mode-alist '("\\.shen\\'" . shen-mode))
(unless (fboundp 'run-shen) (defalias 'run-shen 'inferior-shen))
(add-to-list 'auto-mode-alist '("\\.ss[imt]\\'" . sisu-mode))
(add-to-list 'auto-mode-alist '("\\.st\\'" . smalltalk-mode))
(add-to-list 'auto-mode-alist '("\\.grm\\'" . sml-yacc-mode))
(add-to-list 'auto-mode-alist '("\\.cm\\'" . sml-cm-mode))
(add-to-list 'auto-mode-alist '("\\.s\\(ml\\|ig\\)\\'" . sml-mode))
(unless (fboundp 'run-sml) (defalias 'run-sml 'sml-run))
(add-to-list 'auto-mode-alist '("\\.[Vv][Cc][Ff]\\'" . vcard-mode))
(add-to-list 'auto-mode-alist (cons (purecopy "\\.vcl\\'") 'vcl-mode))
(add-to-list 'auto-mode-alist '("\\.wy\\'" . wisitoken-grammar-mode))
(defconst gnu-elpa--autoloads-table '(("ace-" . "ace-window") ("ack" . "ack") ("adaptive-wrap-prefix-mode" . "adaptive-wrap") ("adjust-parens-mode" . "adjust-parens") ("advice-patch" . "advice-patch") ("aggressive-indent-" . "aggressive-indent") ("all" . "all") ("ampc" . "ampc") ("arbitools-mode" . "arbitools") ("aa2u" . "ascii-art-to-unicode") ("async-" . "async") ("aumix" . "aumix-mode") ("auto-correct-" . "auto-correct") ("auto-overlay" . "auto-overlays") ("pcomplete/a" . "ack") ("provide-me" . "load-relative") ("pabbrev-mode" . "pabbrev") ("paced-" . "paced") ("phps-mode-" . "phps-mode") ("pinentry-start" . "pinentry") ("poker" . "poker") ("posframe-" . "posframe") ("global-aggressive-indent-mode" . "aggressive-indent") ("global-captain-mode" . "captain") ("global-compact-docstrings-mode" . "compact-docstrings") ("global-diff-hl-" . "diff-hl") ("global-nlinum-mode" . "nlinum") ("global-num3-mode" . "num3-mode") ("global-pabbrev-mode" . "pabbrev") ("global-quarter-plane-mode" . "quarter-plane") ("global-undo-tree-mode" . "undo-tree") ("gle-mode" . "gle-mode") ("ggtags-" . "ggtags") ("gited-list-branches" . "gited") ("gnome-c-" . "gnome-c-style") ("gnu-elpa-keyring-update" . "gnu-elpa-keyring-update") ("gnugo" . "gnugo") ("gnus-mock-start" . "gnus-mock") ("gpastel-mode" . "gpastel") ("greader-" . "greader") ("guess-language-mode" . "guess-language") ("gst" . "smalltalk-mode") ("dired-async-" . "async") ("dired-du-" . "dired-du") ("dired-git-info-" . "dired-git-info") ("dictree-" . "dict-tree") ("diff-hl-" . "diff-hl") ("diffview-" . "diffview") ("disk-usage" . "disk-usage") ("dismal-mode" . "dismal") ("darkroom-" . "darkroom") ("dbus-codegen-" . "dbus-codegen") ("delight" . "delight") ("define-hook-" . "hook-helpers") ("define-namespace" . "names") ("define-infix-command" . "transient") ("define-suffix-command" . "transient") ("define-transient-command" . "transient") ("defhydra" . "hydra") ("djvu-" . "djvu") ("docbook-find-file" . "docbook") ("dts-mode" . "dts-mode") ("beacon-" . "beacon") ("bluetooth-list-devices" . "bluetooth") ("bnf-mode" . "bnf-mode") ("brief-" . "brief") ("buffer-expose" . "buffer-expose") ("bug-hunter-" . "bug-hunter") ("caps-lock-mode" . "caps-lock") ("captain-mode" . "captain") ("chess" . "chess") ("clipboard-collector-" . "clipboard-collector") ("cobol-mode" . "cobol-mode") ("coffee-mode" . "coffee-mode") ("compact-docstrings-mode" . "compact-docstrings") ("company-ebdb" . "company-ebdb") ("company-math-symbols-" . "company-math") ("company-latex-commands" . "company-math") ("company-statistics-mode" . "company-statistics") ("context-coloring-" . "context-coloring") ("crisp-mode" . "crisp") ("create-hook-helper" . "hook-helpers") ("csv-mode" . "csv-mode") ("cycle-quotes" . "cycle-quotes") ("tsv-mode" . "csv-mode") ("turn-on-diff-hl-mode" . "diff-hl") ("turn-on-hes-mode" . "highlight-escape-sequences") ("turn-off-hes-mode" . "highlight-escape-sequences") ("tNFA-" . "tNFA") ("temp-buffer-browse-" . "temp-buffer-browse") ("test-simple-" . "test-simple") ("tf-" . "timerfunctions") ("timerfunctions-introduction" . "timerfunctions") ("tiny-" . "tiny") ("transcribe-mode" . "transcribe") ("read-dict" . "dict-tree") ("require-relative" . "load-relative") ("register-list" . "register-list") ("relint-" . "relint") ("rainbow-mode" . "rainbow-mode") ("rcirc-menu" . "rcirc-menu") ("rich-minority-mode" . "rich-minority") ("rm--mode-list-as-string-list" . "rich-minority") ("rnc-mode" . "rnc-mode") ("make-dictree" . "dict-tree") ("make-heap" . "heap") ("markchars-" . "markchars") ("memory-usage" . "memory-usage") ("metar" . "metar") ("midikbd-open" . "midi-kbd") ("mines" . "mines") ("minibuffer-line-mode" . "minibuffer-line") ("minimap-mode" . "minimap") ("mmm-add-classes" . "mmm-mode") ("multishell-" . "multishell") ("log-session-mode" . "dismal") ("load-dirs" . "load-dir") ("load-relative" . "load-relative") ("loccur" . "loccur") ("landmark" . "landmark") ("leaf" . "leaf") ("lex-" . "lex") ("lmc-asm-mode" . "lmc") ("easy-" . "easy-kill") ("ediprolog-" . "ediprolog") ("eev-beginner" . "eev") ("eglot" . "eglot") ("eldoc-" . "eldoc-eval") ("electric-spacing-mode" . "electric-spacing") ("elisp-benchmarks-run" . "elisp-benchmarks") ("enwc" . "enwc") ("epoch-view-mode" . "epoch-view") ("exco" . "excorporate") ("er/expand-region" . "expand-region") ("filladapt-mode" . "filladapt") ("find-file-noselect-relative" . "load-relative") ("fountain-mode" . "fountain-mode") ("frame-tabs-mode" . "frame-tabs") ("frog-menu-" . "frog-menu") ("hes-mode" . "highlight-escape-sequences") ("html-erb-mode" . "mmm-mode") ("ivy-explorer-mode" . "ivy-explorer") ("inferior-shen" . "shen-mode") ("javaimp-" . "javaimp") ("jgraph-mode" . "jgraph-mode") ("js2-" . "js2-mode") ("json-mode" . "json-mode") ("jumpc" . "jumpc") ("with-relative-file" . "load-relative") ("windresize" . "windresize") ("wisitoken-grammar-mode" . "wisitoken-grammar-mode") ("wcheck-" . "wcheck-mode") ("wconf-" . "wconf") ("ws-start" . "web-server") ("webfeeder-" . "webfeeder") ("__FILE__" . "load-relative") ("nxml-web-mode" . "mmm-mode") ("nameless-mode" . "nameless") ("nhexl-mode" . "nhexl-mode") ("nlinum-mode" . "nlinum") ("notes-" . "notes-mode") ("num3-mode" . "num3-mode") ("oauth2-" . "oauth2") ("olivetti-mode" . "olivetti") ("omn-mode" . "omn-mode") ("on-screen-" . "on-screen") ("org-edna-" . "org-edna") ("orgalist-mode" . "orgalist") ("osc-" . "osc") ("other-frame-window-mode" . "other-frame-window") ("style-format" . "psgml") ("sgml-mode" . "psgml") ("scanner-s" . "scanner") ("scroll-restore-mode" . "scroll-restore") ("sed-mode" . "sed-mode") ("shelisp-mode" . "shelisp") ("shen-mode" . "shen-mode") ("sisu-mode" . "sisu-mode") ("sm-c-mode" . "sm-c-mode") ("smalltalk-mode" . "smalltalk-mode") ("smart-yank-mode" . "smart-yank") ("sml-" . "sml-mode") ("sokoban" . "sokoban") ("speed-of-thought-" . "sotlisp") ("spinner-" . "spinner") ("sqlind-" . "sql-indent") ("svg-clock" . "svg-clock") ("snippet-mode" . "yasnippet") ("xml-mode" . "psgml") ("xclip-mode" . "xclip") ("xpm-" . "xpm") ("xr" . "xr") ("quarter-plane-mode" . "quarter-plane") ("undo-tree-mode" . "undo-tree") ("uniq-file-read" . "uniquify-files") ("url-ntlm-auth" . "url-http-ntlm") ("validate-" . "validate") ("vcard-" . "vcard") ("vcl-mode" . "vcl-mode") ("vdiff-" . "vdiff") ("vigenere-" . "vigenere") ("visual-fill-mode" . "visual-fill") ("vlf" . "vlf") ("100secwp" . "wpuzzle") ("yas-" . "yasnippet") ("ztree" . "ztree")))

;; Local Variables:
;; no-byte-compile: t
;; version-control: never
;; no-update-autoloads: t
;; End:

(provide 'gnu-elpa-features)
;;; gnu-elpa-features.el ends here
